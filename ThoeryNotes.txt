1. Explain SOLID principles?

Liskov principle :-
-Derived classes must be substitutable for their base classes without breaking the application.

Why is LSP important in OOP?
Expected Points:
-Ensures reliability and correctness.
-Prevents unexpected behavior.
-Enables polymorphism safely.

How do you detect that a class violates LSP?
Signs:
-Overridden methods throw UnsupportedOperationException.
-Subclass reduces functionality.
-Subclass breaks parentâ€™s expected behavior.
-Subclass changes constraints or rules of the parent.

What happens when LSP is violated?
Expected Points:
-Code breaks when subclass is substituted.
-Unexpected behavior.
-Violations of polymorphism.
-Increased bug risk and maintenance effort.

How to ensure a subclass satisfies LSP?
Rules:
-Do not strengthen preconditions.
-Do not weaken postconditions.
-Preserve invariants (object rules should not change).
-Keep parent behavior consistent.

How is LSP connected to method overriding?
Answer:
-When overriding a method, the subclass must not change:
-Input expectations (preconditions)
-Output guarantees (postconditions)
-Behavior contract defined by the parent

Difference between LSP and OCP (Open Closed Principle)?
-LSP focuses on correct substitution.
-OCP focuses on extending behavior without modifying existing code.
-LSP is required to achieve OCP properly.

Can throwing exceptions violate LSP?
Yes, when:
-Subclass throws new, broader exceptions.
-Subclass throws exceptions that parentâ€™s contract doesnâ€™t allow.

Can returning a broader or different type violate LSP?
Yes, if:
-Returned values change expected behavior.
-Returned result violates constraints (example: null instead of a default object).

Example 1: Flying Bird vs Penguin (Very common interview example)
class Bird {
    public void fly() {
        System.out.println("Bird is flying");
    }
}
Subclass that violates LSP
class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}
ğŸ”¥ How it breaks LSP?
public void makeBirdFly(Bird bird) {
    bird.fly();
}
When we substitute Penguin:
makeBirdFly(new Penguin());  // Runtime exception!
Violations:
âŒ Code breaks â†’ Unexpected exception
âŒ Unexpected behavior â†’ Client expects all Birds to fly
âŒ Polymorphism breaks â†’ Subclass cannot perform the parent behavior
âŒ Bug risk increases â†’ Every place using Bird must add instanceof checks

â­ Correct LSP-compliant fix:
Split into separate interfaces:
interface FlyingBird { void fly(); }
interface WalkingBird { void walk(); }

Penguin â†’ only implements WalkingBird.
---------------------------------------------------------------------------------

Interface segregation principle:-

ğŸ”¥ 1. What is the Interface Segregation Principle (ISP)?
Expected Answer:
Clients should not be forced to depend on interfaces they do not use.
Instead of one large interface, create smaller, specific interfaces.

ğŸ”¥ 2. Why is ISP important?
Expected Points:
-Avoids bloated (fat) interfaces
-Reduces unnecessary method implementations
-Prevents classes from having empty or dummy implementations
-Makes systems more maintainable and flexible

ğŸ”¥ 3. Give a real example where ISP is violated.
Bad Interface:
interface Worker {
    void work();
    void eat();
    void sleep();
}
Subclass violating ISP:
class Robot implements Worker {
    public void work() { }
    public void eat() {}  // âŒ Robot doesn't eat!
    public void sleep() {} // âŒ Robot doesn't sleep!
}
Robot is forced to implement methods it doesnâ€™t need ğŸ‘

ğŸ”¥ 4. How do you fix the above violation using ISP?
Correct interfaces:
interface Workable { void work(); }
interface Eatable { void eat(); }
interface Sleepable { void sleep(); }

Now Robot only implements what it needs:
class Robot implements Workable {
    public void work() {}
}


ğŸ”¥ 5. How do you identify ISP violations in a system?
Look for:
-Classes implementing methods with empty bodies
-Classes throwing UnsupportedOperationException
-Interfaces with too many unrelated methods
-Classes only using a few methods from a large interface

ğŸ”¥ 6. Can abstraction be used to avoid ISP violations?
Yes. Splitting interfaces into:
-Role-specific
-Behavior-specific
Allows classes to depend only on what they use.

ğŸ”¥ 7. Does ISP lead to more interfaces? Is that a problem?
Yes, ISP increases the number of interfaces, but:
-Code becomes cleaner
-Interfaces become more reusable
-Classes depend only on necessary behavior
-Easier to mock in testing
So more interfaces = better separation.

ğŸ”¥ 8. Can you give an ISP example from real-life Java libraries?
Javaâ€™s InputStream and OutputStream
Each interface has focused responsibilities
They avoid combining reading + writing into one interface
This design follows ISP.

ğŸ”¥ 9. How does ISP relate to LSP?
ISP: â€œDon't force me to implement what I donâ€™t need.â€
LSP: â€œIf I extend something, I must honor its behavior.â€
ISP reduces the risk of LSP violations

ğŸ”¥ 10. Explain ISP using a payment example.
Bad Interface:
interface Payment {
    void pay();
    void refund();
    void applyDiscount();
}
UPI payment doesnâ€™t support refunds â†’ forced to implement unnecessary method.
Discount-exclusive payments forced to implement discount logic.
Fix:
interface Payable { void pay(); }
interface Refundable { void refund(); }
interface Discountable { void applyDiscount(); }

Now each payment type chooses what it supports.

--------------------------------------------------------------------------------------------------------------

Dependency inversion principle:-
The principle of dependency inversion refers to the decoupling of software modules.
This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.

1. What is the Dependency Inversion Principle (DIP)?
Expected Answer:
-High-level modules should not depend on low-level modules.
-Both should depend on abstractions (interfaces).

2. How is DIP different from regular abstraction?
Most people mix this up.
Expected Answer:
Abstraction hides implementation details.
DIP forces both high-level and low-level code to depend on that abstraction.
DIP changes the dependency direction â†’ details depend on abstraction

3. What is an example of DIP in a layered architecture?
Good Answer:
-Controller â†’ depends on Service interface
-Service â†’ depends on Repository interface
-Repository â†’ concrete DB implementation
None of the higher layers know the low-level details.

4. How does DIP improve unit testing?
Expected Answer:
-Allows mocking low-level dependencies
-Reduces reliance on actual DB, network, or file system
-Enables dependency injection for test doubles

5. What is â€œinversionâ€ in DIP?
Expected Answer:
Normally, high-level code depends on low-level code.
DIP inverts this direction â†’ both depend on abstraction.

6. Can DIP be applied without DI frameworks like Spring?
Yes
Ways:
Constructor Injection
Factory Pattern
Service Locator Pattern
Passing dependencies manually
DIP does not require Spring â€” Spring only automates it.

7. Give an example of DIP violation in real life.
Example:
A logging class directly uses FileLogger.
class SystemManager {
    private FileLogger logger = new FileLogger();
}
You cannot replace FileLogger with ConsoleLogger easily â†’ tightly coupled

8. How do factories help in implementing DIP?
Expected Answer:
Factories create concrete objects.
High-level modules depend only on the factory interface, not the concrete implementation.

9. How does DIP relate to Open/Closed Principle?
Expected Answer:
-DIP enables OCP.
-You can add new concrete implementations without modifying high-level code.
-High-level modules remain unchanged â†’ they rely on interfaces

10. Does using interfaces always mean DIP is followed?
NO.
Example:
class A {
  B b;
  A() { b = new B(); }  // Even though B implements an interface, A depends on B
}
Even with interfaces, direct instantiation violates DIP.

11. Is DIP violated if an interface becomes too large?
Yes â†’ that also violates Interface Segregation Principle (ISP).
ISP supports DIP by ensuring abstractions are clean and focused.

12. Provide a small DIP-compliant code example (short answer).
interface Storage{
    void save(String data);
}

public class FileStorage implements Storage{
    void save(String data){

    }
}

class DataService {
    private Storage storage;

    public DataService(Storage storage){
        this.storage = storage;
    }

    public void saveData(String data){
        storage.save(data);
    }
}


==============================================================================

Q: How one service can communicate with other within microservice architecture?
In a Microservice Architecture, one service communicates with another using well-defined communication patterns.
There are two major styles:

ğŸŸ¦ 1. Synchronous Communication (Real-Time API Calls)
Service A calls Service B and waits for a response.
Common protocols:
âœ” REST APIs (HTTP) â€“ most popular
Service A â†’ calls â†’ http://service-b/api/data

âœ” gRPC (high-performance + binary protocol)
Useful for low-latency, high-throughput systems

âœ” Feign Client (Spring Cloud OpenFeign)
Declarative REST client used in Spring Boot microservices.

âœ” WebClient / RestTemplate
WebClient â†’ modern, non-blocking
RestTemplate â†’ older, still used

ğŸŸ© 2. Asynchronous Communication (Event-Driven)
Services do not wait for each other.
They communicate through messages or events.
Common tools:
âœ” Message Brokers
Kafka
RabbitMQ
ActiveMQ
AWS SNS/SQS
Google Pub/Sub
Service A publishes an event â†’
Service B listens and processes it later.

âœ” Event Bus / Stream Processing
Kafka Streams
Kinesis
Flink

ğŸ”¥ In simple terms:
âœ” Sync â†’ Service A waits
âœ” Async â†’ Service A sends message and forgets

ğŸ¯ Interview Ready Answer
"Microservices communicate using synchronous methods like REST, gRPC, Feign Client or asynchronous message brokers like Kafka, RabbitMQ.
Communication is managed using Service Discovery (Eureka/Consul) and API Gateway.
Async messaging helps loose coupling while sync calls are used for real-time responses."

===========================================================================================================

Q:- what is eureka nd consul?
Eureka and Consul are Service Discovery tools used in microservice architectures.
Their main job is to help microservices find each other dynamically without hardcoding IP addresses.

ğŸŸ¦ Why do we need Service Discovery?
In microservices:
services run on multiple instances
they scale up/down automatically
they get new IPs when containers restart
services may run on different machines
ğŸ‘‰ Hardcoding URLs/IPs becomes impossible.
Service Discovery solves this.

ğŸŸ¦ 1. Eureka (from Netflix OSS)
Eureka is a service registry used mainly with Spring Cloud microservices.
â¤ How it works:
Each service registers itself at the Eureka Server.
Eureka keeps a list of all running service instances.
Services ask Eureka to find other services.

ğŸŸ¦ Key Features of Eureka
âœ” Self-registration (services register themselves)
âœ” Client-side load balancing
âœ” Heartbeats to detect if service is UP
âœ” Works perfectly with Spring Cloud + Feign client
âœ” Pure Java ecosystem

ğŸŸ¦ 2. Consul (from HashiCorp)
Consul is a service discovery + configuration + health check tool.
It is more advanced and widely used in DevOps-heavy systems.
ğŸŸ© Co nsul Features
âœ” Service discovery (like Eureka)
âœ” Key-value store (for config management)
âœ” Health checks (built-in)
âœ” Distributed system support
âœ” Works outside Java â†’ supports all languages
âœ” DNS-based discovery
âœ” Works great with Kubernetes

ğŸŸ¦ Eureka vs Consul â€” Interview Table
| Feature              | Eureka               | Consul                    |
| -------------------- | -------------------- | ------------------------- |
| Language ecosystem   | Java/Spring Cloud    | All languages             |
| Health checks        | Basic                | Advanced, built in        |
| Config store         | No                   | Yes (Key-Value Store)     |
| Load balancing       | Ribbon (client side) | Usually via Envoy/Sidecar |
| Kubernetes support   | Weak                 | Excellent                 |
| Production readiness | Good                 | Excellent                 |
| DevOps tooling       | Limited              | Strong                    |


ğŸ¯ Interview Ready Answer
â€œEureka and Consul are service discovery tools used in microservices.
Eureka (from Netflix) is widely used in Spring Cloud applications for registering and discovering services.
Consul (from HashiCorp) is more advanced and provides service discovery, health checks, DNS-based lookup, and configuration management.
Eureka fits Java ecosystems well, while Consul is language-agnostic and ideal for modern cloud environments.â€

Refer MicroserviceCommunicationTest.txt

-----------------------------------------------------------------------------------------------

Q:- how the security is handled within microservice architecture?
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚          CLIENT             â”‚
                        â”‚  (Web / Mobile / Backend)   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                          (Login: username/password)
                                       â”‚
                                       â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚      IDENTITY PROVIDER      â”‚
                         â”‚   (Keycloak / Auth0 / Okta) â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                       (Returns OAuth2 Access Token - JWT)
                                       â”‚
                                       â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚         API GATEWAY           â”‚
                        â”‚ (Spring Cloud Gateway / Kong) â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚             â”‚                          â”‚
                  â–¼             â–¼                          â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  SERVICE A     â”‚  â”‚  SERVICE B     â”‚      â”‚  SERVICE C     â”‚
        â”‚  Business logicâ”‚  â”‚ Business logic â”‚      â”‚ Business logic â”‚
        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ (JWT Verified)        â”‚ (JWT Verified)          â”‚
            â”‚                        â”‚                        â”‚
            â”‚  Service-to-Service Calls with OAuth2 Token     â”‚
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚                        â”‚                        â”‚
      (mTLS/HTTPS)          (mTLS/HTTPS)                (mTLS/HTTPS)
            â”‚                        â”‚                        â”‚
            â–¼                        â–¼                        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   DATABASE / CACHE  â”‚  â”‚   DATABASE / CACHE  â”‚  â”‚   DATABASE / CACHE â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. API Gateway (Central Entry Point)
All incoming requests pass through an API Gateway.
Responsibilities:
Authentication & Authorization
Rate limiting
Routing to downstream services
Token validation
Logging

Popular Gateways:
Spring Cloud Gateway
NGINX
Kong
AWS API Gateway

2. Authentication & Authorization (OAuth2 / JWT)
Most Common Pattern:
ğŸ”¹ User logs in â†’ gets JWT or OAuth2 access token
ğŸ”¹ Token is sent with every request (Authorization: Bearer <token>)
ğŸ”¹ Microservices validate the token (no DB query needed)

Why JWT?
Stateless
Fast
Verifiable using public/private keys
Works perfectly with distributed systems

3. Service-to-Service Security (Internal Communication)
A. Using JWT Between Services
Each microservice communicates with another by sending a service JWT issued by an IAM server (e.g., Keycloak, Auth0, Okta).
Example:
Service-A â†’ calls Service-B
Authorization: Bearer <service-token>
Service-B validates token â†’ allows/denies.

B. Mutual TLS (mTLS)
Very common inside modern microservice clusters like Kubernetes.
How it works:
Service-A and Service-B both have certificates
Both verify each other (two-way SSL handshake)
This ensures:
Identity verification
Encrypted communication
Zero trust security
Tools that enable mTLS:-
Istio service mesh
Linkerd
Envoy proxy

4. API Gateway + OAuth2 + Keycloak Example (Common Architecture)
Client â†’ API Gateway â†’ Microservices

Client â†’ login
API Gateway â†’ Keycloak (validates JWT)
Gateway â†’ forwards request â†’ Microservices
Microservices â†’ validate JWT signature

5. Secure Inter-Service Communication With Feign + OAuth2
   Example (Spring Boot):
   Service A â†’ calling Service B using OAuth2 token
   Explore it?

6. API Security Best Practices
âœ” Validate JWT in every service
Use public key verification (RSA256)
âœ” Use Role-based or Attribute-based access control
ROLE_USER
ROLE_ADMIN
SCOPE_read
âœ” Use API Gateway for incoming traffic only
âœ” Use TLS everywhere (HTTPS)
âœ” Rotate secrets & certificates regularly
âœ” Use Vault for storing secrets
(HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager)
âœ” Encrypt sensitive data (DB, logs)
âœ” Rate limiting / Throttling
Avoid DDoS on services


7. TL;DR (Short Interview Answer)
In microservices, security is handled using an API Gateway, OAuth2/JWT-based authentication,
mutual TLS for internal service-to-service calls, and centralized identity providers like Keycloak or Auth0.
Tokens are validated inside each service, and communication is encrypted using HTTPS/mTLS.
Secrets are stored in vaults and rotated regularly.

Explore these?
If you want, I can also give you:
âœ… Code for API Gateway + JWT
âœ… Keycloak-based authentication example
âœ… Secure service-to-service call example
Just tell me!

==========================================================================


Java 17 features must know?

1ï¸âƒ£ Java 17 is an LTS (Long Term Support)
Simple explanation:
Java 17 is a long-term support version, meaning companies use it in production for many years with stability
and security updates.
ğŸ“Œ Good opening line in interview.

2ï¸âƒ£ Sealed Classes (Very Important â­)
What it does:
Restricts which classes can extend a class or implement an interface.
Why needed:
Improves security, design control, and maintainability
Example:
public sealed class Vehicle permits Car, Bike {}
final class Car extends Vehicle {}
final class Bike extends Vehicle {}
Explain like this:
Sealed classes allow us to control inheritance so only specific classes can extend a class.

public sealed abstract class Payment
        permits CreditCardPayment, UpiPayment, NetBankingPayment {
    public abstract void pay(double amount);
}

public final class CreditCardPayment extends Payment {
    @Override
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using Credit Card");
    }
}

public final class UpiPayment extends Payment {
    @Override
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using UPI");
    }
}

public final class NetBankingPayment extends Payment {
    @Override
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using Net Banking");
    }
}

public class PaymentService {
    public static void main(String[] args) {
        Payment payment = new UpiPayment();
        payment.pay(1500);
    }
}

4ï¸âƒ£ Why Sealed Class is Useful (Say This in Interview â­)
Sealed classes allow us to restrict inheritance and define a fixed set of subclasses.
This improves security, design clarity, and makes the code easier to maintain.


3ï¸âƒ£ Records (Highly Popular â­)
What it does:
Used to create immutable data objects
Removes boilerplate code (getters, setters, equals, hashCode, constructor)
Example:
public record Employee(int id, String name) {}
Explain like this:
Records are used for DTOs or response objects where data should not change.

Traditional Class (Before Records)
public class Employee {
    private final int id;
    private final String name;
    private final String department;

    public Employee(int id, String name, String department) {
        this.id = id;
        this.name = name;
        this.department = department;
    }

    public int getId() { return id; }
    public String getName() { return name; }
    public String getDepartment() { return department; }

    @Override
    public boolean equals(Object o) { /* boilerplate */ }
    @Override
    public int hashCode() { /* boilerplate */ }
    @Override
    public String toString() { /* boilerplate */ }
}
âŒ Too much code for a simple data holder.
Same Thing Using Record (Java 17) â­
public record Employee(int id, String name, String department) {}
âœ… Compiler automatically creates
Constructor
Getters (id(), name(), department())
equals(), hashCode(), toString()
All fields are final (immutable)

Using the Record
public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee(101, "Pawan", "Backend");

        System.out.println(emp.name());
        System.out.println(emp);
    }
}

Record with Validation (Important Interview Point â­)
You can add validation in the constructor.
public record Employee(int id, String name) {

    public Employee {
        if (id <= 0) {
            throw new IllegalArgumentException("Id must be positive");
        }
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
    }
}

Record with Methods
public record Employee(int id, String name, double salary) {

    public boolean isHighEarner() {
        return salary > 100000;
    }
}

Where Records Are Used (Say This in Interview)
Records are mainly used for DTOs, API responses, request objects, and immutable data models.
Examples:
Spring Boot REST response
Database query results
Event objects

What records CANNOT do âŒ
| Limitation                        | Reason                      |
| --------------------------------- | --------------------------- |
| Fields cannot be mutable          | Records are immutable       |
| Cannot extend another class       | Implicitly extends `Record` |
| No setters                        | By design                   |
| Cannot have instance initializers | Use constructors instead    |


| Feature     | Class          | Record        |
| ----------- | -------------- | ------------- |
| Boilerplate | High           | Very low      |
| Mutability  | Mutable        | Immutable     |
| Best for    | Business logic | Data carriers |


4ï¸âƒ£ Pattern Matching for instanceof
Before Java 17:
if (obj instanceof String) {
    String s = (String) obj;
}
Java 17:
if (obj instanceof String s) {
    System.out.println(s.length());
}
Explain like this:
Java 17 removes explicit casting when using instanceof, making code cleaner and safer.

5ï¸âƒ£ Enhanced Switch Expression
Whatâ€™s new:
Switch can return values
No need for break
Example:
String result = switch (day) {
    case "SAT", "SUN" -> "Weekend";
    default -> "Weekday";
};
Explain like this:
Switch expressions are more readable and less error-prone than traditional switch statements.

public class SwitchExample {

    public static void main(String[] args) {
        String day = "SAT";

        String result = switch (day) {
            case "SAT", "SUN" -> "Weekend";
            case "MON", "TUE", "WED", "THU", "FRI" -> "Weekday";
            default -> "Invalid day";
        };

        System.out.println(result);
    }
}

Switch with yield (When logic is complex)
public class DiscountCalculator {

    public static int getDiscount(String customerType) {

        return switch (customerType) {
            case "PREMIUM" -> {
                int discount = 20;
                yield discount;
            }
            case "REGULAR" -> {
                int discount = 10;
                yield discount;
            }
            default -> 0;
        };
    }
}

Switch + Sealed Class (Advanced but Impressive â­)
sealed interface Payment permits Card, Upi {}

final class Card implements Payment {}
final class Upi implements Payment {}

public class PaymentService {

    static String process(Payment payment) {
        return switch (payment) {
            case Card c -> "Card payment";
            case Upi u -> "UPI payment";
        };
    }
}
ğŸ“Œ No default
ğŸ“Œ Compiler checks exhaustiveness
ğŸ’¡ Why this is better
No break
Returns a value
More readable and less error-prone
ğŸ—£ Interview Explanation
Java 17 switch expressions allow returning values and grouping cases, making code cleaner and safer.
| Old Switch     | Java 17 Switch |
| -------------- | -------------- |
| Needs `break`  | No `break`     |
| Statement only | Expression     |
| Error-prone    | Safer          |
| Less readable  | More readable  |


6ï¸âƒ£ Text Blocks
Used for:
Writing JSON, SQL, HTML easily
Example:
String query = """
    SELECT * FROM users
    WHERE active = true
    """;
Explain like this:
Text blocks make multi-line strings readable and avoid escape characters.

7ï¸âƒ£ Strong Encapsulation of JDK Internals
What it means (simple):
Internal JDK APIs are no longer accessible directly.
Why important:
Improves security and stability
Interview line:
Java 17 strongly encapsulates internal APIs to prevent unsafe usage.

8ï¸âƒ£ New Garbage Collectors Improvements
Improved G1 GC
Better performance and memory management
Safe interview line:
Java 17 has performance improvements and better garbage collection tuning.