Phase 1: Spring Boot Fundamentals (This Week)
 Goal: Build a basic REST API with full understanding of layers.

 Concept	What to Learn	Why It Matters
‚úÖ Project setup	Use Spring Initializr with Maven	Standard project starter
‚úÖ @SpringBootApplication	Auto-configuration, component scan	Entry point of app
‚úÖ REST Controller	@RestController, @GetMapping, etc.	Handle HTTP requests
‚úÖ Service Layer	@Service	Business logic lives here
‚úÖ Repository Layer	@Repository, JPA, H2/MySQL	Data access layer
‚úÖ Dependency Injection	@Autowired, Constructor injection	Core Spring concept
‚úÖ Application.properties	Configure port, DB, logging	Environment setup

- implementation of IoC principle
- spring framework runtime 
Core containers
Bean , Core, Context, spel

- Spring needs multiple configuration to be done by you.

- Spring boot helps u to create stand-alone, production grade, spring-based 
application that you can run
more of like a plug and play solution!
e.g., Netflix is using springboot in most of their production applications

- Inversion of Control
It is a popular programming principle used extensively in the design of modern software
frameweorks e.g., in springboot
It refers to the practice of inverting the control of the system by delegating the control
of the relationships of the objects to the separate component or container rather than letting
each object control its own Dependencies and lifecycle

- Dependency Injection
Is specialised form of IoC, whereby objects define their Dependencies, ( that is, the other objects they work with) only through 
Constructor arguments, arguments to a factory method properties that are set on the object instance after it is constructed or returned 
from a factory method

- Benefits of IoC
Modularity :- promotes modular app development through Dependency injection
Ease of testing :- Makes it easier to test out the code by injecting mock implementations.
Loose coupling :- Reduces dependencies between components , making it easier to manage and evolve applications

- Spring IoC container & Application Context
Spring IoC container: manages the instantiation, configuration & assembly of beans.
Types of contaienrs:-
Bean factory:- Basic container functionality, suitable for simple applications.
Application context :- More advanced , supporting internationalization, event propagation, declarative mechanism to configure a bean.

In summary , Application context is the Spring IoC container that manages the 
beans (POJOs) for us.

03/07/2025

2.4 Beans:- beans are objects that r instantiated, managed and assembled by spring IoC container
Bean scope :- 
singleton : single instance per spring IoC container
Prototype: a new instance each time a bean is requested
Request, session and global session

Bean scope defines how many objects Spring should create for a particular bean ‚Äî and when.

üîπ 1. Singleton (default)
üîÅ One instance per Spring container
All requests for this bean will return the same object, Default scope in Spring. e.g., Example: Useful for stateless services, config beans.

üîπ 2. Prototype
üÜï A new object is created each time you request the bean, Not shared, not managed after creation. e.g., Example: Useful for stateful beans, like forms.

üîπ 3. Request (Web only)
üßæ One bean instance per HTTP request, Bean lives only during the request.

üîπ 4. Session
üßë‚Äçüíº One bean instance per HTTP session ,Lives as long as the user session is active.

üîπ 5. Global Session
üó∫Ô∏è Like session scope, but for portlet-based apps (rare today) ,used in legacy systems, mostly irrelevant now.



-------------------------------------------------------------------------------

Project :- 
1. Let me know if you want a mini-project or example using 
prototype vs singleton beans ‚Äî it‚Äôs a cool way to feel the difference.

---------------------------------------------------------------------------------

13/07/2025

1. Annotations!
@SpringBootApplication	Indicates a configuration class that declares one or more @Bean methods and 
also triggers auto-configuration and component scanning.

@RestController	Combines @Controller and @ResponseBody to simplify the creation of RESTful web services.

@RequestMapping	Provides routing information and is used to map web requests to specific handler classes or methods.

@GetMapping	A composed annotation that acts as a shortcut for @RequestMapping(method = RequestMethod.GET).
@PostMapping	A composed annotation that acts as a shortcut for @RequestMapping(method = RequestMethod.POST).
@PutMapping	A composed annotation that acts as a shortcut for @RequestMapping(method = RequestMethod.PUT).
@DeleteMapping	A composed annotation that acts as a shortcut for @RequestMapping(method = RequestMethod.DELETE).
@PatchMapping	A composed annotation that acts as a shortcut for @RequestMapping(method = RequestMethod.PATCH).

@Autowired	Marks a constructor, field, setter method, or config method as to be autowired by Spring's dependency injection facilities.

@Component	Indicates that an annotated class is a "component". Such classes are considered as candidates for auto-detection when using
 annotation-based configuration and classpath scanning.

@Service	Indicates that an annotated class is a "Service" (e.g., a business service facade).

@Repository	Indicates that an annotated class is a "Repository" (e.g., a Data Access Object or DAO).

@Configuration	Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and
 service requests for those beans at runtime.

@Bean	Indicates that a method produces a bean to be managed by the Spring container.

@Value	Indicates a default value expression for the annotated element.

@PropertySource	Provides a convenient and declarative mechanism for adding a PropertySource to Spring's Environment.

@EnableAutoConfiguration	Enables Spring Boot‚Äôs auto-configuration mechanism.

-----------------------------------------------------------------------------------------------------------------------------------------------------

15/08/2025

1. Dependency injection
1Ô∏è‚É£ Start with the big picture
Dependency Injection (DI) is a way to give an object the things it needs (dependencies) instead of having the object create them itself.

In Spring Boot ‚Üí Spring does this for you automatically through its IoC (Inversion of Control) container.

Interview-friendly analogy:

Imagine you need a car for a trip.
Without DI ‚Üí You build the car yourself (engine, tires, etc.).
With DI ‚Üí You just tell the rental company ‚ÄúI need a car,‚Äù and they hand you a ready-made car.
Spring is the rental company here ‚Äî it creates and supplies the needed objects.

2Ô∏è‚É£ Why it matters in Spring Boot
Loose coupling ‚Üí Classes depend on interfaces, not specific implementations.
Easier testing ‚Üí You can inject mock dependencies.
Centralized configuration ‚Üí You don‚Äôt hardcode dependencies everywhere.

3Ô∏è‚É£ How Spring Boot does it
Spring manages all objects (called Beans) in the ApplicationContext.
You tell Spring what beans you need, and it injects them into your class.

4Ô∏è‚É£ Ways DI is done in Spring Boot
a) Constructor Injection (Preferred)
@Service
public class OrderService {
    private final PaymentService paymentService;

    @Autowired  // Optional in newer Spring versions
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    public void placeOrder() {
        paymentService.processPayment();
    }
}
b) Setter Injection
@Service
public class OrderService {
    private PaymentService paymentService;

    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
c) Field Injection (Not recommended for large projects)
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
}
5Ô∏è‚É£ What happens under the hood
Spring Boot scans packages for classes annotated with @Component, @Service, @Repository, @Controller.
It creates bean instances for them.
When a class needs another bean, Spring injects it using the method you defined (constructor/setter/field).

6Ô∏è‚É£ Bonus for the interview
DI is a special case of IoC: In IoC, the framework controls object creation; DI is specifically about injecting dependencies.
Best practice: Use constructor injection in Spring Boot because it makes dependencies explicit and allows immutability.

Interview one-liner:
In Spring Boot, Dependency Injection means Spring automatically supplies the objects your class needs, instead of your class creating them itself.
It‚Äôs implemented through the IoC container, making code loosely coupled, testable, and easier to maintain.


16/08/2025

1. What is auto-configuration?

2. POST vs PUT vs DELETE vs PATCH vs GET?
üîπ PUT
Purpose: Replace the entire resource.
Behavior: Whatever fields you don‚Äôt send will typically be set to null or default.
Idempotent: Multiple identical PUT calls ‚Üí same final state.
PUT /users/1
{
  "name": "John",
  "email": "john@mail.com",
  "age": 30
}
Replaces the whole user with exactly these values. If "age" is missing, it might become null.

üîπ PATCH
Purpose: Update a partial resource (only some fields).
Behavior: Only modifies the fields you send, leaves the rest untouched.
Idempotency: Depends on implementation, but usually safe if same patch applied multiple times.
PATCH /users/1
{
  "email": "john.new@mail.com"
}
Only updates the email, keeps name and age as they were.
‚úÖ In short:
PUT = replace everything (full update).
PATCH = modify only what you send (partial update).

‚úÖ When to use PUT
You expect the client to always send the full resource representation.
The API semantics are replace-the-whole-object.
Example:
Updating a user profile where the front-end always submits all fields from a form.
Replacing a configuration file stored in DB.
Rule: Client owns the whole state, server just replaces it.

‚úÖ When to use PATCH
You expect the client to send only the fields it wants to update.
Useful for large resources or sparse updates (don‚Äôt resend unchanged data).
Example:
Updating only the email field of a user.
Changing just the status field of an order ("status": "shipped").
Rule: Client only specifies the delta (changes), server merges into existing state.

Practical Notes
Idempotency:
PUT is always idempotent ‚Üí sending the same request multiple times results in the same final state.
PATCH is usually idempotent, but can be non-idempotent if designed poorly (e.g., "age": "+1" instead of "age": 31).

Performance:
PUT may require sending large payloads every time.
PATCH is lighter, better for mobile apps or bandwidth-sensitive clients.

Error safety:
With PUT, if you forget a field ‚Üí it may be overwritten with null.
With PATCH, omitted fields remain intact.

üëâ Rule of Thumb:
Use PUT if your resource is small and simple, and full replacement makes sense.
Use PATCH if your resource is big, partially editable, or frequently updated field-by-field.

3. auto-configuration vs annotation-based-configuration vs componentScanning vs class path scanning?
3.1. Auto-Configuration (Spring Boot feature)
What: Spring Boot automatically configures beans in the application context based on classpath contents and property settings.
How: Driven by @EnableAutoConfiguration (included in @SpringBootApplication).
Example:
If spring-boot-starter-data-jpa is on the classpath ‚Üí Spring Boot auto-configures a DataSource, EntityManagerFactory, JpaRepositories.
If spring-boot-starter-web is present ‚Üí auto-configures DispatcherServlet, Jackson ObjectMapper, etc.
Benefit: Reduces boilerplate ‚Äî you don‚Äôt need to manually configure common beans.

3.2. Annotation-based Configuration
  What: Using annotations to explicitly tell Spring how to create and inject beans.
  Examples:
  @Configuration + @Bean ‚Üí define beans manually in a class.
  @Autowired ‚Üí inject a bean automatically.
  @Component, @Service, @Repository, @Controller ‚Üí mark classes as beans.
  Benefit: More control than auto-config. You explicitly define what Spring should manage.

3.3. Component Scanning
What: Spring scans specified packages for classes annotated with @Component (or @Service, @Repository, @Controller, etc.), and automatically registers them as beans.
How: Enabled by @ComponentScan (included by default in @SpringBootApplication).
Example:
@SpringBootApplication
@ComponentScan("com.example.myapp") // tells Spring where to look
public class MyApp {}
‚Üí Finds all @Service, @Controller, etc. in com.example.myapp and registers them.

3.4. Classpath Scanning
What: The mechanism Spring uses under the hood to scan the classpath (JARs, packages, folders) to find candidate classes for beans.
Relation: Component Scanning is a specialized case of classpath scanning that looks specifically for annotated components.
Example: When you use @ComponentScan("com.example"), Spring performs a classpath scan under com.example and registers beans.

üîë Key Differences (Summary)
Feature	What it Does	Who Controls It	Example
Auto-Configuration	Spring Boot provides default beans based on classpath & properties	Spring Boot	Auto-configured DataSource when JDBC driver is present
Annotation-based Config	Explicit bean definition via annotations	You (developer)	@Bean, @Autowired, @Service
Component Scanning	Scans packages for @Component-style annotations	You (developer)	@ComponentScan("com.example")
Classpath Scanning	Underlying process of scanning the classpath for classes	Spring Framework	Used by component scanning & auto-config

‚úÖ In short:
Auto-configuration ‚Üí Boot gives you beans automatically (opinionated defaults).
Annotation-based ‚Üí You explicitly define beans and dependencies.
Component scanning ‚Üí Spring automatically registers annotated beans in specified packages.
Classpath scanning ‚Üí The low-level mechanism Spring uses to find those annotated classes.

4. What is Spring AOP?
‚úÖ Simple Definition
AOP (Aspect-Oriented Programming) is a way to keep common/repeated code (like logging, security, transactions)
in one place instead of writing it again and again in every class or method.
You write that repeated logic once in a separate class (aspect).
Spring will automatically apply it wherever needed, without you touching the business logic.

‚úÖ Example Without AOP
Suppose you have 3 service methods:
public void createOrder() {
    System.out.println("Logging start..."); // repeated
    // business logic
    System.out.println("Logging end...");   // repeated
}
public void updateOrder() {
    System.out.println("Logging start..."); // repeated
    // business logic
    System.out.println("Logging end...");   // repeated
}
public void deleteOrder() {
    System.out.println("Logging start..."); // repeated
    // business logic
    System.out.println("Logging end...");   // repeated
}
‚ùå Problem ‚Üí Logging code is repeated everywhere.

‚úÖ Example With AOP
With AOP, you move logging into an aspect:
@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() {
        System.out.println("Logging start...");
    }

    @After("execution(* com.example.service.*.*(..))")
    public void logAfter() {
        System.out.println("Logging end...");
    }
}
Now your createOrder(), updateOrder(), deleteOrder() only contain business logic.
Spring automatically adds logging before and after method calls.

‚úÖ Analogy
Think of AOP like CCTV in a building:
Instead of placing one security guard in every room (repeating effort),
You install one CCTV system (aspect) that watches all rooms automatically.

üëâ So in an interview, you can say:
"AOP in Spring lets me separate repeated code like logging or security into a separate module (aspect) and apply it automatically, so my business logic stays clean."

4.1 What is AOP?
Aspect-Oriented Programming (AOP): A way to separate cross-cutting concerns from business logic.
Cross-cutting concerns: Repeated logic that affects multiple modules
Examples: Logging, Security, Transactions, Caching, Performance Monitoring, Exception Handling.
AOP allows you to write such logic in one place (aspect) and apply it declaratively.

4.2 AOP Concepts (Core Terminology)
Term	Meaning
Aspect	A module containing cross-cutting concern (e.g., @Aspect class for logging).
Join Point	A point in the program execution where AOP can be applied (e.g., method execution).
Advice	The action taken at a join point (e.g., logging, transaction).
Pointcut	Expression that selects join points (e.g., all methods in a package).
Weaving	Process of applying aspects to target objects.
Proxy	Spring uses JDK Dynamic Proxies or CGLIB to apply AOP without modifying actual code.

4.3 Types of Advice (Most Asked in Interviews)
Advice	When it Runs	Example
Before (@Before)	Before target method execution	Log input params
After Returning (@AfterReturning)	After successful execution	Log return value
After Throwing (@AfterThrowing)	If method throws exception	Log error
After (Finally) (@After)	Always after method (success or exception)	Cleanup resources
Around (@Around)	Wraps method execution (before + after)	Measure execution time, modify arguments

4.4 Pointcut Expressions
  Spring AOP uses AspectJ expression syntax.
  Common designators:
  execution(* com.example.service.*.*(..)) ‚Üí any method in service package.
  execution(public * *(..)) ‚Üí any public method.
  execution(* *(..)) ‚Üí any method with any return type.
  @annotation(MyAnnotation) ‚Üí methods annotated with @MyAnnotation.

4.6 Spring AOP Internals
  Proxy-based AOP:
  Spring AOP is proxy-based ‚Üí wraps beans with proxies.
  Uses JDK Dynamic Proxy (if interface exists) OR CGLIB (if no interface).
  Runtime Weaving (Proxy-based): Spring AOP weaves aspects at runtime.

  AspectJ vs Spring AOP:
  Spring AOP = runtime, proxy-based, method-level only.
  AspectJ = compile-time or load-time weaving, more powerful (supports field, constructor, etc.).

4.7 Real-World Use Cases
Logging: Log method entry/exit.
Security: Check authentication/authorization before executing a method.
Transactions: Mark methods @Transactional (Spring uses AOP behind the scenes).
Caching: Cache method results (@Cacheable uses AOP).
Performance Monitoring: Measure method execution time.

4.8 Pros & Cons
‚úÖ Advantages:
Separation of concerns (business logic vs cross-cutting logic).
Reduces boilerplate code.
Easy to apply consistently across app.
‚ö†Ô∏è Disadvantages:
Debugging can be harder (logic runs outside actual code).
Limited compared to AspectJ (method execution only)

4.9 Common Interview Questions
What is AOP in Spring? Difference between OOP and AOP?
What are the types of advice in AOP?
What is the difference between JoinPoint and Pointcut?
How does Spring implement AOP (JDK Proxy vs CGLIB)?
Difference between Spring AOP and AspectJ?
Real-world examples where you would use AOP.
How does @Transactional internally work? (‚Üí via AOP proxy).
What is weaving and when does it happen in Spring?

10. One-Line Crib Notes for Interview
AOP = clean way to apply cross-cutting concerns.
Aspect = class with advices.
Advice = action (before, after, around).
Pointcut = where advice applies.
Spring AOP = proxy-based, runtime, method-level only.
AspectJ = more powerful, compile/load-time weaving.
Real-world: logging, security, transactions, caching.

Pro tip for interview: if asked "Have you used AOP?" you can mention:
@Transactional (transaction management)
@Cacheable (caching)
Custom @Aspect for logging execution time.

5. How does @Transaction internally works?
5.1. What happens when you put @Transactional on a method/class?
Spring sees the annotation during bean creation (via TransactionAnnotationParser).
It creates a proxy object (using JDK dynamic proxies or CGLIB) that wraps your bean.
This proxy intercepts method calls ‚Üí checks if the method/class has @Transactional.

5.2. Proxy workflow when you call a transactional method
You call service.saveUser().
The proxy intercepts the call before your real method runs.
The proxy delegates to TransactionInterceptor, which:
Looks at the transaction metadata (propagation, isolation, timeout, readOnly).
Talks to the PlatformTransactionManager (e.g., DataSourceTransactionManager for JDBC).
TransactionManager:
Starts a new transaction OR joins an existing one.
Sets up a connection with proper auto-commit=false.
Your actual method (saveUser()) executes.
After execution:
If no exception ‚Üí commit.
If runtime exception ‚Üí rollback (default behavior).
(Checked exceptions rollback only if configured).

5.3 Key Notes
AOP Proxy: That‚Äôs why only public methods are transactional (by default). Calls to this.saveUser() inside the same class won‚Äôt go through proxy.
Thread-bound transaction: Spring binds the connection to the current thread using TransactionSynchronizationManager.
Commit/Rollback happens at the proxy level, not inside your method.

üëâ So in one line:
@Transactional works by wrapping your bean in an AOP proxy that starts/commits/rolls back transactions around method execution, using a TransactionManager.

5.4 Example
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class EngineerService {

    private final EngineerRepository repo;

    public EngineerService(EngineerRepository repo) {
        this.repo = repo;
    }

    // Transactional method
    @Transactional
    public Engineer createEngineerWithRollback(String name, String skill) {
        Engineer e = new Engineer();
        e.setName(name);
        e.setSkill(skill);
        repo.save(e);

        // simulate error ‚Üí triggers rollback
        if (true) {
            throw new RuntimeException("Simulated Exception ‚Üí triggers rollback");
        }

        return e;
    }
}

5.6 What Happens Internally

Spring creates a proxy around EngineerService.
When you call createEngineerWithRollback(), instead of calling it directly, you actually call the proxy method.
The proxy starts a transaction before executing the method.
If the method completes successfully ‚Üí commit.
If it throws a runtime exception ‚Üí rollback.
So AOP proxy is the mechanism behind @Transactional.

5.7 Analogy:
    Think of proxy as a bank manager assistant:
    Before giving you money (running method), he opens a vault (transaction).
    If everything goes fine, he locks vault safely (commit).
    If robbery/alarm (exception), he resets vault to previous state (rollback).

5.8 How the Proxy Handles the Call:
    When you call a transactional method:
    Proxy intercepts the call.
    The TransactionInterceptor checks metadata from @Transactional (like isolation, propagation, rollback rules).
    It asks the PlatformTransactionManager (like DataSourceTransactionManager or JpaTransactionManager) to:
    Start a new transaction OR
    Join an existing one (depending on Propagation type).
    Your actual method executes inside that transaction context.
    After method returns:
    If it completes successfully, interceptor tells TransactionManager ‚Üí commit.
    If it throws a runtime exception (or checked exception marked as rollbackFor), interceptor tells TransactionManager ‚Üí rollback.

6. Explain @SpringbootApplication ?
@SpringBootConfiguration
Same as @Configuration.
Tells Spring that this class contains bean definitions (methods annotated with @Bean).
@Configuration is an annotation in Spring.
It marks a class as a configuration class (like a replacement for applicationContext.xml).
Inside such a class, you can write methods with @Bean ‚Üí each method creates and returns a Spring-managed bean.
Spring will automatically pick them up and put them in the ApplicationContext.
Marks a class as a Spring config class, where methods annotated with @Bean create beans for the Spring container.

If you ever want a custom bean:
@SpringBootApplication
public class MyApp {

    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
üëâ Here PasswordEncoder is not auto-configured, so you define it.
‚úÖ Simplified answer for interview:
@SpringBootApplication tells Spring Boot:
"This is my main configuration class."
It will auto-configure most beans for me.
I can still define custom @Bean methods if I need to override or add extra beans.

@EnableAutoConfiguration
Tells Spring Boot to automatically configure beans based on classpath dependencies.
Example:
If spring-boot-starter-web is in the classpath ‚Üí it will auto-configure Tomcat, DispatcherServlet, etc.
    Tomcat:
    ‚û°Ô∏è Tomcat is the default embedded web server in Spring Boot that provides the servlet container to run and serve web applications.
    DispatcherServlet:
    ‚û°Ô∏è DispatcherServlet is the front controller in Spring MVC that receives all incoming HTTP requests and delegates them to the appropriate controller/handler.
If spring-boot-starter-data-jpa is in the classpath ‚Üí it will auto-configure EntityManagerFactory, DataSource, TransactionManager, etc.
    EntityManagerFactory
    ‚û°Ô∏è Creates and manages EntityManager instances which interact with the database in JPA.
    DataSource
    ‚û°Ô∏è Represents the database connection pool configuration (URL, username, password, driver).
    TransactionManager
    ‚û°Ô∏è Manages database transactions (commit/rollback) across multiple operations, ensuring data consistency.

@ComponentScan
Scans the current package and its subpackages for components (@Component, @Service, @Repository, @Controller, etc.).
This way, you don‚Äôt have to register beans manually


7. - Explain Dependency Injection, Autowired?
Dependency Injection (DI)
üëâ Instead of a class creating its own dependencies, Spring injects them for you.
Without DI
class Car {
    private Engine engine = new Engine(); // Car creates Engine
}

With DI
class Car {
    private Engine engine;  // Car depends on Engine, but doesn‚Äôt create it

    public Car(Engine engine) {
        this.engine = engine; // Spring injects Engine here
    }
}
‚û°Ô∏è Benefit: Loose coupling (easy to test, maintain, and swap implementations).

@Autowired

üëâ Spring‚Äôs way to automatically inject dependencies.
@Service
public class CarService {

    @Autowired   // Spring will provide Engine bean automatically
    private Engine engine;

    public void startCar() {
        engine.start();
    }
}
@Autowired can be used on:
Constructor (best practice in modern Spring)
Setter method
Field (works, but less recommended)

‚úÖ In one line interview answer:
DI: Design pattern where Spring provides required dependencies instead of creating them manually.
@Autowired: Annotation that tells Spring to inject a matching bean automatically.

Spring supports 3 types of DI: field, setter, and constructor.
Field injection is simplest but not recommended (hard to test, hidden deps).
Setter injection is good for optional dependencies.
Constructor injection is the best practice ‚Üí makes dependencies explicit, supports immutability, and easier for unit testing.

8. - What is the difference between inject and autowired?
üîπ @Autowired (Spring-specific)
Package: org.springframework.beans.factory.annotation.Autowired
Provided by: Spring framework.
Behavior:
By default, it autowires by type (looks for a matching bean by type).
If multiple beans of the same type exist ‚Üí requires @Qualifier or bean name.
required=true by default ‚Üí will throw exception if no matching bean is found.

üîπ @Inject (Standard Java)
Package: javax.inject.Inject (part of JSR-330 standard, not Spring-specific).
Provided by: Java Dependency Injection specification (Jakarta).
Behavior in Spring: Works almost the same as @Autowired, since Spring supports JSR-330 annotations.
No required attribute (unlike @Autowired).
Usually used when you want your code to be framework-agnostic (portable across DI containers, not tied to Spring).

üîπ Key Differences (Interview One-Liners):
@Autowired ‚Üí Spring-specific, has more features (e.g., required=false).
@Inject ‚Üí Standard Java (JSR-330), no Spring dependency.
Both perform dependency injection, but @Autowired gives more fine-grained control in Spring

9. - What Design patterns are used in Spring Boot?
‚úÖ Design Patterns used in Spring Boot
Singleton Pattern
Spring beans by default are singleton-scoped (one instance per Spring container).
Manages memory and consistency.
Factory Pattern
The BeanFactory and ApplicationContext act as factories to create and manage beans.
Prototype Pattern
When you mark a bean as @Scope("prototype"), a new instance is created each time it‚Äôs requested.
Proxy Pattern
Used in AOP (Aspect Oriented Programming) for cross-cutting concerns like logging, transactions, security.
Also in Spring Security (method-level security).
Observer Pattern
Implemented in the Spring Events mechanism (ApplicationEventPublisher, @EventListener).
Helps components communicate in a loosely coupled way.
Decorator Pattern
Used with BeanPostProcessor and @Transactional where additional behavior is "wrapped" around a bean.
Template Method Pattern
Used in JdbcTemplate, RestTemplate, JpaTemplate ‚Üí they handle the boilerplate and let you focus on the custom logic.
Builder Pattern
Used in many places like MockMvcBuilders, ResponseEntity, or Lombok‚Äôs @Builder with Spring Boot DTOs.
Adapter Pattern
Spring MVC uses HandlerAdapter to map requests to controllers in a uniform way.
Dependency Injection (DI) ‚Üí not a GoF pattern, but a fundamental principle
Achieved via @Autowired, @Inject, or constructor injection.

‚úÖ Interview-friendly Summary:
"Spring Boot internally uses many design patterns. Singleton for beans, Factory via BeanFactory, Proxy for AOP and Security, Observer for events,
Template Method in JDBC/REST templates, Adapter in MVC, and Decorator in transactions, builder in lombork
 These patterns make Spring Boot flexible, extensible, and loosely coupled."

10.- What are Spring Boot annotations?
Spring Boot makes heavy use of annotations to simplify configuration, reduce boilerplate, and enable declarative programming.
‚úÖ Interview Tip: If asked ‚Äî ‚ÄúWhy so many annotations in Spring Boot?‚Äù
üëâ Because annotations help achieve inversion of control, declarative programming, and reduce XML configuration.

11. - BeanFactory vs ApplicationContext, Eager and Lazy loading?
BeanFactory vs ApplicationContext
BeanFactory
Core container, responsible for managing beans.
Uses lazy loading (beans created only when requested).
Lightweight ‚Üí good for memory-constrained apps.
Provides only basic DI features.

ApplicationContext
Advanced container built on top of BeanFactory.
Uses eager loading by default (beans created at startup).
Provides enterprise features: event propagation, internationalization (i18n), AOP, bean post-processors, etc.
Recommended in Spring Boot apps.

Eager vs Lazy Loading
Eager Loading (default in ApplicationContext):
All singleton beans are created at application startup.
Ensures faster runtime performance (beans ready in advance).
Increases startup time & memory usage.

Lazy Loading (default in BeanFactory, or via @Lazy in Spring Boot):
Beans created only when first requested.
Saves memory and improves startup time.
May cause slight delay when bean is accessed first time.

‚úÖ Quick One-liner Summary (for interviews):
BeanFactory = basic DI container, lazy loading.
ApplicationContext = advanced container with enterprise features, eager loading by default.
Eager = faster runtime, slower startup; Lazy = faster startup, slower first use.

import org.springframework.stereotype.Component;

@Component
public class EagerBean {

    public EagerBean() {
        System.out.println("EagerBean Initialized!");
    }

    public void hello() {
        System.out.println("Hello from EagerBean");
    }
}

import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

@Component
@Lazy
public class LazyBean {

    public LazyBean() {
        System.out.println("LazyBean Initialized!");
    }

    public void hello() {
        System.out.println("Hello from LazyBean");
    }
}

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;
@Component
public class TestRunner implements CommandLineRunner {

    @Autowired
    private EagerBean eagerBean;

    @Autowired
    private LazyBean lazyBean; // Lazy bean injected but not yet initialized

    @Override
    public void run(String... args) {
        System.out.println("Inside CommandLineRunner...");

        // Eager bean was already created at startup
        eagerBean.hello();

        // Lazy bean created only now (when first used)
        lazyBean.hello();
    }
}


12. What is cascading in Spring Boot?
Definition: Cascading means that a persistence operation (like persist, merge, remove, refresh, detach) applied to one entity
 also gets automatically applied to its related entities.
Purpose: It helps avoid writing repetitive code for saving/updating/deleting associated objects.

@Entity
public class Customer {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    // Customer can have many orders
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();
}

@Entity
public class Order {

    @Id
    @GeneratedValue
    private Long id;

    private String product;

    @ManyToOne
    private Customer customer;
}
--------------
Customer customer = new Customer();
customer.setName("John");

Order order1 = new Order();
order1.setProduct("Laptop");
order1.setCustomer(customer);

Order order2 = new Order();
order2.setProduct("Phone");
order2.setCustomer(customer);

customer.getOrders().add(order1);
customer.getOrders().add(order2);

// Only saving customer, but orders will also be saved
customerRepository.save(customer);

üîπ Types of Cascade
PERSIST ‚Üí Saves child when parent is saved.
MERGE ‚Üí Updates child when parent is updated.
REMOVE ‚Üí Deletes child when parent is deleted.
REFRESH ‚Üí Refreshes child when parent is refreshed from DB.
DETACH ‚Üí Detaches child when parent is detached from persistence context.
ALL ‚Üí Applies all above operations

üìù Interview one-liner
Cascading in Spring Boot (JPA) means that persistence operations performed on a parent entity are automatically propagated to its child entities,
 reducing boilerplate code for saving, updating, or deleting related objects.

13. - Controller vs RestController?
1. @Controller
Used in Spring MVC web applications.
Marks a class as a controller that can handle HTTP requests.
Usually returns a View (like JSP, Thymeleaf, etc.) along with Model data.
You need to annotate methods with @ResponseBody if you want to return JSON/XML directly.

@Controller
public class MyController {

    @GetMapping("/hello")
    @ResponseBody   // Needed to return raw JSON/string
    public String sayHello() {
        return "Hello from Controller";
    }
}

2. @RestController
Shortcut for @Controller + @ResponseBody.
Used for REST APIs (returns JSON/XML directly instead of rendering views).
No need to add @ResponseBody on every method.
@RestController
public class MyRestController {
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello from RestController"; // Returned as JSON response
    }
}

14. - What are @Component and @Bean annotations?
@Component
Purpose: Marks a class as a Spring-managed bean.
When to use: When you want Spring to automatically detect and register your class as a bean during component scanning (@ComponentScan).
@Component
public class PaymentService {
    public void processPayment() {
        System.out.println("Processing payment...");
    }
}
@Bean
Purpose: Tells Spring that a method will return a bean that should be managed by the Spring container.
When to use: When you need manual control over how a bean is created (e.g., 3rd party classes, custom initialization).
@Configuration
public class AppConfig {

    @Bean
    public PaymentService paymentService() {
        return new PaymentService(); // manually creating the bean
    }
}
Key Differences
Feature	@Component	@Bean
Usage	Placed on class	Placed on method
Bean Creation	Automatic via classpath scanning	Manual via method return
Best for	Your own classes	External classes / fine-grained bean creation
Configuration	Requires @ComponentScan	Requires @Configuration

15. RestTemplate vs webClient?
‚úÖ Key Differences
Feature	RestTemplate (Old)	WebClient (New)
Style	Blocking (Sync)	Non-blocking (Async)
Performance	Not suitable for high concurrency	Scales better under load
API	Imperative	Reactive
Status	Deprecated	Recommended

So in interviews:
Say RestTemplate is legacy (synchronous).
WebClient is modern (reactive, non-blocking), and should be used going forward.

Using @RestController and using RestTemplate are two different things:
@RestController ‚Üí Marks your class as a REST API controller (your app exposes endpoints).
RestTemplate / WebClient ‚Üí Are clients used when your app calls some other API.
So:
‚úÖ If your app was only exposing APIs (e.g., @GetMapping("/users")) but not calling external APIs,
    you might not have used RestTemplate or WebClient at all.
‚úÖ If your app did make outbound API calls, then you need to check:
Did you see code like restTemplate.getForObject(...)? ‚Üí You used RestTemplate.
Did you see code like WebClient.create().get()...? ‚Üí You used WebClient.
üëâ @RestController just means your app was a server for REST APIs. It doesn‚Äôt imply which client library you used (or if you used one at all).

16. - Used Cassandra or Redis or Elasticsearch?
‚ÄúI haven‚Äôt worked with Cassandra/Redis/Elasticsearch directly in my last project. But I do understand their purpose and differences:
Cassandra is good for high-volume, distributed NoSQL storage. (planning for storing flight position data for given tailId)
Redis is mainly used as an in-memory key-value store and cache. ( for storing tailIds in-memory and their internet-connectivityStatus)
Elasticsearch is optimized for full-text search and analytics. (used in splunk)
I‚Äôve worked with relational databases and caching layers, so I can quickly pick up whichever is needed.‚Äù

17. - PostMapping vs RequestMapping?
@RequestMapping
A general-purpose annotation used to map HTTP requests to handler methods or classes.
Can be applied at both class level and method level.
It is flexible: supports all HTTP methods (GET, POST, PUT, DELETE, etc.) via the method attribute.

@RequestMapping(value = "/hello", method = RequestMethod.GET)
public String sayHello() {
    return "Hello World!";
}

@PostMapping
A specialized version of @RequestMapping that is shortcut for POST requests.
Improves readability and reduces boilerplate.
@PostMapping("/createUser")
public String createUser(@RequestBody User user) {
    return "User created!";
}
‚úÖ Key Differences
Feature	@RequestMapping	@PostMapping
Purpose	General-purpose mapping for any HTTP method	Specifically maps only POST requests
Readability	More verbose (requires method = RequestMethod.POST)	Cleaner & concise
Usage	Can define multiple HTTP methods in one mapping	Only for POST

18. - Path variable vs query parameter vs path parameter vs request body?
1. Path Variable (@PathVariable)
Part of the URL path itself.
Used when the value is mandatory and uniquely identifies a resource.
@GetMapping("/users/{id}")
public User getUser(@PathVariable String id) {
    return userService.findById(id);
}

2. Query Parameter (@RequestParam)
Part of the URL after the ?.
Often optional and used for filtering, sorting, or pagination.
@GetMapping("/users")
public List<User> getUsers(@RequestParam(required = false) String role) {
    return userService.findByRole(role);
}
GET /users?role=admin

3. Path Parameter
It‚Äôs the same as Path Variable ‚Äî just different terminology.
REST APIs sometimes call placeholders in the URL path "path parameters."
Example: /users/{id} ‚Üí {id} is a path parameter.
In Spring Boot, we implement it with @PathVariable

4. Request Body (@RequestBody)
Used for sending structured data (like JSON, XML) in the HTTP request body.
Usually for POST, PUT, PATCH.
Example:
@PostMapping("/users")
public User createUser(@RequestBody User user) {
    return userService.save(user);
}
‚úÖ Summary Table
Aspect	Path Variable	Query Parameter	Request Body
Location	URL path	After ? in URL	Inside HTTP body
Usage	Resource ID	Filtering, optional	Data payload
Annotation in Spring	@PathVariable	@RequestParam	@RequestBody
Example URL	/users/123	/users?role=admin	Body: JSON/XML

‚ÄúWhen to use what?‚Äù ‚Üí Use Path Variable for identifying a resource, Query Param for filters/options, Request Body for sending full objects.

19. what is @Primary annotation!
@Primary is used when multiple beans of the same type are available in the Spring context, and you want to mark one of them as the default choice for autowiring.
Without it, Spring would throw an ambiguity error (NoUniqueBeanDefinitionException).

Example in primaryAnnotation folder !
What happens?
Both CreditCardPayment and PaypalPayment implement PaymentService.
If no hint is given, Spring would be confused.
But since PaypalPayment is marked with @Primary, it becomes the default bean injected.

How is it different from @Qualifier?
@Primary ‚Üí declares a default bean among candidates.
@Qualifier ‚Üí gives explicit control, you specify exactly which bean to inject.

e.g.,
@Autowired
@Qualifier("creditCardPayment")
private PaymentService paymentService;


-----------------------------------------------------------------------------
Q: What are bean scopes and bean lifecycle in springboot?
‚ÄúIn Spring, a bean scope defines how many instances of a bean the container should create and how long it should live. The most commonly used scopes are:
Singleton (default): One instance for the entire application. Used for stateless services.
Prototype: A new instance is returned every time the bean is requested.
Request: One instance per HTTP request (used in web applications).
Session: One instance per user session.
Application: One instance per ServletContext.
About the Bean Lifecycle, Spring manages the entire lifecycle of a bean. The steps are:

Instantiation: Spring creates the bean object.

Dependency Injection: It injects all required dependencies.

Aware callbacks: If the bean implements interfaces like BeanNameAware or ApplicationContextAware, Spring calls them.

BeanPostProcessor (before init): postProcessBeforeInitialization() runs.

Initialization: Spring performs initialization by calling:
@PostConstruct
afterPropertiesSet() (if implementing InitializingBean)
Custom init method

BeanPostProcessor (after init): postProcessAfterInitialization() runs.
Note:-
When you implement a BeanPostProcessor, it logs (or processes) every single bean that Spring creates ‚Äî not just your beans.
This includes internal Spring framework beans, infrastructure beans, and proxy beans.
That‚Äôs why you see weird names like:
"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"
"org.springframework.aop.config.internalAutoProxyCreator"
"requestMappingHandlerMapping"
"mvcValidator"
"handlerExceptionResolver"
"myService"
"aopProxy"
"scopedTarget.myBean"

‚úÖ Why does this happen?
BeanPostProcessor is global.
Spring registers your BeanPostProcessor before any beans are created, so it intercepts:
Controller beans
Repository beans
Service beans
Configuration beans
Internal Spring beans
AOP proxies
Auto-generated beans
So your postProcessBeforeInitialization() or postProcessAfterInitialization() method gets invoked hundreds of times, once per bean.

üî• Why does Spring create so many beans?
Because Spring Boot auto-configures:
MVC (DispatcherServlet, converters, resolvers)
Web security
AOP
Caching
Jackson
DataSource
Health endpoints
Actuator
Configuration processors
All of these become Spring-managed beans ‚Üí which means your BeanPostProcessor intercepts them.

üß† Interview-Friendly Explanation
‚ÄúBeanPostProcessor applies to every bean in the IoC container.
So it will process user-defined beans as well as internal framework beans.
This is why you see many beans and unusual bean names in the logs.‚Äù

Destruction: When the context closes, Spring calls:
@PreDestroy
destroy()
Custom destroy method.

This lifecycle ensures proper setup and cleanup of beans, and scopes define how many instances Spring should manage.‚Äù
üéØ Interview-Ready Answer (30 seconds)
‚ÄúSpring Bean Lifecycle starts with instantiation, then dependency injection.
If the bean implements Aware interfaces, Spring calls their methods.
Next, BeanPostProcessors run before initialization.
Initialization includes @PostConstruct, afterPropertiesSet(), and any custom init method.
After that, postProcessAfterInitialization runs and the bean becomes ready.
During shutdown, Spring calls @PreDestroy, destroy(), and custom destroy methods for cleanup.‚Äù

===================================================================================================

Q: what are actuators?
Spring Boot Actuators are production-ready features that give you insights, metrics, health checks,
and control endpoints to monitor and manage your application in real time.
‚úÖ What are Actuators in simple terms?
Actuators expose REST endpoints to help you know:
Is the application UP or DOWN?
What are the memory/CPU metrics?
Which beans are created?
What environment variables are loaded?
What thread dumps exist?
What configurations are active?
Health of DB / Redis / Messaging system
Application info (version, build details)

üü© 1. Add the dependency
In Spring Boot:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

üü© 2. Common Actuator Endpoints
| Endpoint               | Purpose                               |
| ---------------------- | ------------------------------------- |
| `/actuator/health`     | App health (UP/DOWN)                  |
| `/actuator/info`       | App info (version, description)       |
| `/actuator/beans`      | List all Spring beans                 |
| `/actuator/loggers`    | View/update logging levels            |
| `/actuator/metrics`    | System metrics (CPU, memory, threads) |
| `/actuator/env`        | View environment properties           |
| `/actuator/mappings`   | All controller mappings               |
| `/actuator/heapdump`   | Download heap dump                    |
| `/actuator/threaddump` | View thread dump                      |
| `/actuator/conditions` | Auto-configuration report             |

Actuators provide monitoring and management endpoints that help DevOps teams track application health,
metrics, thread usage, logs, and internal configurations.
They are essential for production environments because they support observability, troubleshooting,
and system monitoring.

To expose ALL endpoints:
management.endpoints.web.exposure.include=*

To see DB health details:
management.endpoint.health.show-details=always

Default path is /actuator.
To change:
management.endpoints.web.base-path=/manage

================================================================================

27/12/2025

http://interviewbit.com/spring-boot-interview-questions/

Q: What is dependency Injection?
The process of injecting dependent bean objects into target bean objects is called dependency injection.
Setter Injection: The IOC container will inject the dependent bean object into the target bean object by calling the setter method.
Constructor Injection: The IOC container will inject the dependent bean object into the target bean object by calling the target bean constructor.
Field Injection: The IOC container will inject the dependent bean object into the target bean object by Reflection API.

Constructor injection
| Criterion      | Result      | Why                             |
| -------------- | ----------- | ------------------------------- |
| Unit testing   | ‚úÖ Excellent | No Spring, no reflection        |
| Immutability   | ‚úÖ Yes       | `final` field                   |
| Mandatory deps | ‚úÖ Yes       | Cannot create object without it |


Setter Injection ‚ö†Ô∏è (OPTIONAL DEPENDENCY)
| Criterion      | Result | Why                            |
| -------------- | ------ | ------------------------------ |
| Unit testing   | ‚ö†Ô∏è OK  | Must remember setter           |
| Immutability   | ‚ùå No   | Field cannot be `final`        |
| Mandatory deps | ‚ùå No   | Object exists in invalid state |


Field Injection ‚ùå (AVOID)
| Criterion      | Result   | Why                        |
| -------------- | -------- | -------------------------- |
| Unit testing   | ‚ùå Poor   | Needs Spring or reflection |
| Immutability   | ‚ùå No     | No `final`                 |
| Mandatory deps | ‚ùå Hidden | Dependency invisible       |


üìä Final Comparison Table (INTERVIEW READY)
| Injection Type       | Unit Test | Immutability | Mandatory Deps | Verdict |
| -------------------- | --------- | ------------ | -------------- | ------- |
| Constructor          | ‚úÖ Easy    | ‚úÖ Yes        | ‚úÖ Yes          | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê   |
| Setter               | ‚ö†Ô∏è Medium | ‚ùå No         | ‚ùå No           | ‚≠ê‚≠ê      |
| Field                | ‚ùå Hard    | ‚ùå No         | ‚ùå Hidden       | ‚ùå       |
| Lombok + Constructor | ‚úÖ Easy    | ‚úÖ Yes        | ‚úÖ Yes          | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê   |


üéØ Golden Rule (Remember this)
If a dependency is mandatory ‚Üí Constructor Injection
If a dependency is optional ‚Üí Setter Injection
Never use Field Injection in production code

-------------------------------------------------------------------------------------------

Q: What is unit testing , explain in simple terms wrt constructor injection?
1Ô∏è‚É£ First: What is Unit Testing? (Very simple)
üëâ Unit testing means testing ONE small unit (class or method) in isolation
without running the full application or Spring Boot.

In your case, the unit is: OrderServiceConstructor
You want to check:
‚ÄúDoes placeOrder() work correctly if I give it a PaymentService?‚Äù

@Test ‚Äî What is this?
This annotation comes from JUnit
It tells Java:
‚ÄúThis method is a test case, not normal application code‚Äù
JUnit will:
Run this method automatically
Check if it passes or fails

Why fake it?
Because:-
You don‚Äôt want real payment logic
You just want to test OrderService logic
üëâ This fake object is called a mock (or stub).

What is this proving?
You are not using Spring
You are not starting the application
You are just using new
This is possible only because of constructor injection.
üìå This line proves:
Constructor injection makes the class easy to test

Test starts
 ‚Üì
Create fake PaymentService
 ‚Üì
Create OrderService with fake dependency
 ‚Üì
Call placeOrder()
 ‚Üì
Fake paymentService.pay() runs
 ‚Üì
Returns "mock payment"
 ‚Üì
assertEquals passes
 ‚Üì
Test SUCCESS ‚úÖ

Why is this test IMPORTANT?
It proves 3 things:
‚úÖ 1. Business logic works
placeOrder() returns what it should
‚úÖ 2. Dependency is replaceable
You can swap real payment with fake one
‚úÖ 3. Code is well-designed
No Spring, no DB, no server required

üî¥ What would happen with Field Injection?
OrderServiceField service = new OrderServiceField();
service.placeOrder(); // üí• NullPointerException
Because:
You cannot inject dependency manually
You need Spring context

üîë Core Concept to Remember (Very Important)
Unit tests test YOUR code, not Spring, not DB, not APIs
That‚Äôs why constructor injection is powerful.

One-Sentence Explanation (Interview Level)
This unit test creates a fake implementation of PaymentService, injects it via constructor, calls the method under test,
and verifies the output using an assertion‚Äîwithout starting Spring or using real dependencies.

===================================================================================================

Interview Questions from interviewBits

1. What is the difference between @RestController and @Controller in Spring Boot?
@Controller Map of the model object to view or template and make it human readable but @RestController simply returns the
object and object data is directly written in HTTP response as JSON or XML.

@Controller
Used for MVC (Model‚ÄìView‚ÄìController) applications
Typically returns a view name (HTML, JSP, Thymeleaf, etc.)
Response is rendered using a ViewResolver
To return JSON/XML, you must explicitly add @ResponseBody

@RestController
Used for REST APIs
Automatically returns JSON/XML
No view rendering
Internally = @Controller + @ResponseBody

| Feature                | `@Controller`        | `@RestController`       |
| ---------------------- | -------------------- | ----------------------- |
| Purpose                | Web MVC (views)      | REST APIs               |
| Returns                | View name by default | JSON/XML by default     |
| View Resolver          | Yes                  | No                      |
| `@ResponseBody` needed | Yes (for API)        | No                      |
| Best use case          | HTML pages           | Backend services / APIs |

When to use what?
‚úÖ Use @Controller
When building web pages (Thymeleaf, JSP, etc.)
‚úÖ Use @RestController
When building REST APIs for frontend/mobile apps
-----------------------------------------------------------
2. Whats the difference between mvc app and rest api app?
1Ô∏è‚É£ MVC App (Model‚ÄìView‚ÄìController App)
An MVC app is a server-side rendered application where:
The backend generates the UI (HTML)
Browser directly displays what the server sends
Browser ‚Üí Server ‚Üí Controller ‚Üí View (HTML) ‚Üí Browser

What backend returns
HTML pages
CSS/JS (sometimes)
Data embedded inside HTML

Where it‚Äôs used
Traditional web apps
Admin panels
Internal tools
Apps using Thymeleaf, JSP

Pros
‚úÖ Simple
‚úÖ SEO-friendly
‚úÖ Less frontend complexity
Cons
‚ùå UI tightly coupled to backend
‚ùå Harder to build mobile apps
‚ùå Not ideal for modern SPAs

2Ô∏è‚É£ REST API App
What it is
A REST API app:
Backend only provides data
Frontend (React, Angular, Mobile app) handles UI
Flow
Browser / Mobile / App ‚Üí API ‚Üí JSON ‚Üí Frontend renders UI

What backend returns
JSON or XML
HTTP status codes

Where it‚Äôs used
React / Angular / Vue apps
Mobile apps (Android / iOS)
Microservices
Backend-for-frontend

Pros
‚úÖ Frontend & backend decoupled
‚úÖ Reusable APIs
‚úÖ Scales well
‚úÖ Works with mobile apps
Cons
‚ùå Needs separate frontend
‚ùå Slightly more setup

| Feature         | MVC App         | REST API App             |
| --------------- | --------------- | ------------------------ |
| UI Rendering    | Server-side     | Client-side              |
| Response Type   | HTML            | JSON / XML               |
| Frontend        | Part of backend | Separate                 |
| Controller Type | `@Controller`   | `@RestController`        |
| Best For        | Simple web apps | Modern web & mobile apps |

3. How Spring handles MVC vs REST internally?
Both MVC and REST in Spring use the same core pipeline.
HTTP Request
   ‚Üì
DispatcherServlet   (Front Controller)
   ‚Üì
Handler Mapping
   ‚Üì
Controller Method
   ‚Üì
Handler Adapter
   ‚Üì
Response Processing
   ‚Üì
HTTP Response
üëâ The difference is NOT in request routing
üëâ The difference is in response handling

1Ô∏è‚É£ DispatcherServlet (Common for both)
Single entry point for all HTTP requests
Defined by Spring MVC framework
Decides which controller method should handle the request
Tomcat ‚Üí DispatcherServlet ‚Üí Spring
‚úî Same for MVC and REST
‚úî No difference here

2Ô∏è‚É£ Handler Mapping (Common)
Spring scans:
@Controller
@RestController
@RequestMapping, @GetMapping, etc.
It builds a map like:
/home     ‚Üí HomeController.home()
/users/1  ‚Üí UserController.getUser()
‚úî Same mapping logic for both

3Ô∏è‚É£ Controller Invocation (Common)
Spring calls the matched method.
Example:
@GetMapping("/users/1")
public User getUser() { ... }
At this point:
Spring does not yet know if this is MVC or REST
It just has a return value

4Ô∏è‚É£ üî• Where MVC vs REST Actually Split
Key Decision:
Is @ResponseBody present?
Annotation	Implies
@Controller	‚ùå No
@RestController	‚úÖ Yes (implicitly)
Spring checks:
Is this response body data or a view name?

5Ô∏è‚É£ MVC Internal Flow (@Controller)
Example
@Controller
public class HomeController {
    @GetMapping("/home")
    public String home() {
        return "home";
    }
}
Internal Handling
Method returns "home"
Spring assumes this is a view name
ViewResolver kicks in
Finds template:
home.html (Thymeleaf)
or home.jsp
View engine renders HTML
HTML is sent to browser
Internal Chain
Controller ‚Üí ViewResolver ‚Üí View ‚Üí HTML
üìå No JSON serialization
üìå No HttpMessageConverter

6Ô∏è‚É£ REST Internal Flow (@RestController)
Example
@RestController
public class UserController {

    @GetMapping("/user")
    public User getUser() {
        return new User("Pawan", 28);
    }
}
Internal Handling
Method returns User object
@ResponseBody is detected
Spring skips ViewResolver
HttpMessageConverter is selected
Jackson converts object ‚Üí JSON
JSON written directly to response body
Internal Chain
Controller ‚Üí HttpMessageConverter ‚Üí JSON
üìå No view rendering
üìå Pure data response

7Ô∏è‚É£ What is HttpMessageConverter?
It converts Java ‚Üî HTTP body
Converter	Purpose
MappingJackson2HttpMessageConverter	JSON
StringHttpMessageConverter	Text
ByteArrayHttpMessageConverter	Binary
FormHttpMessageConverter	Form data

Spring picks one based on:
Accept header
Return type
Content-Type

Summary
| Stage          | MVC               | REST                 |
| -------------- | ----------------- | -------------------- |
| Entry          | DispatcherServlet | DispatcherServlet    |
| Routing        | HandlerMapping    | HandlerMapping       |
| Controller     | `@Controller`     | `@RestController`    |
| Output         | View name         | Data                 |
| Processor      | ViewResolver      | HttpMessageConverter |
| Final Response | HTML              | JSON                 |

Spring doesn‚Äôt care if it‚Äôs MVC or REST until the controller returns something.

---------------------------------------------------------------------------

3. How content negotiation works (Accept header)
Content negotiation in Spring is how Spring decides which format (JSON, XML, text, etc.) to send back based on the client‚Äôs Accept header.
1Ô∏è‚É£ What is Content Negotiation?
Content negotiation =
üëâ Client tells server what formats it can accept
üëâ Server chooses the best one it can produce

Client says (Accept header): Accept: application/json
Server responds:
Content-Type: application/json

2Ô∏è‚É£ Accept Header (Client Side)
The Accept header can contain multiple media types with priorities.
Simple
Accept: application/json

Multiple formats
Accept: application/json, application/xml
With priority (quality factor q)
Accept: application/xml;q=0.9, application/json;q=0.8
Higher q = higher preference.

3Ô∏è‚É£ Where Spring Handles This Internally
After your controller method returns data:
Controller
   ‚Üì
@ResponseBody detected
   ‚Üì
ContentNegotiationManager
   ‚Üì
HttpMessageConverter selected
   ‚Üì
Response written

6Ô∏è‚É£ Using produces to Restrict Output
@GetMapping(value = "/user", produces = "application/json")
public User getUser() {
    return new User("Pawan", 28);
}
If client sends:
Accept: application/xml
Result:
406 Not Acceptable

7Ô∏è‚É£ What if Accept Header is Missing?
If no Accept header:
Spring uses default media type
Usually:
application/json
(because Jackson is on classpath)

üìå Browsers often send:
Accept: text/html,application/xhtml+xml,application/xml
Which is why:
MVC apps return HTML
REST APIs still return JSON (due to @ResponseBody)

9Ô∏è‚É£ ContentNegotiationManager (Advanced)
Spring uses ContentNegotiationManager to decide media type based on:
Accept header (most common)
URL extension (/user.json) ‚ùå discouraged
Request parameter (?format=json) ‚ùå discouraged
Spring Boot defaults to Accept-header-based negotiation.

üîü Common Interview Traps ‚ö†Ô∏è
‚ùì Why JSON returned even when browser Accepts HTML?
Because:
@RestController forces @ResponseBody
ViewResolver is skipped
JSON converter wins

‚ùì Difference between Accept and Content-Type?
Header	Direction
Accept	Client ‚Üí Server (what I want back)
Content-Type	Client ‚Üí Server (what I‚Äôm sending)

--------------------------------------------------------

4. What is an IOC container?
IoC Container is a framework for implementing automatic dependency injection.
It manages object creation and its life-time and also injects dependencies into the class.

An IoC container (Inversion of Control container) is the core of Spring.
It is responsible for creating, managing, and wiring objects (beans) so you don‚Äôt have to.
‚úî Creates objects (beans)
‚úî Injects dependencies
‚úî Manages lifecycle
‚úî Applies configuration
In Spring:
ApplicationContext = IoC container
BeanFactory = basic container

With IoC
The framework controls object creation.
class Car {
    private Engine engine;

    Car(Engine engine) {
        this.engine = engine;
    }
}
üëâ You don‚Äôt create Engine
üëâ Spring injects it
This reversal of control = Inversion of Control

3Ô∏è‚É£ What Does the IoC Container Actually Do?
1. Scan configuration
@ComponentScan
@Configuration
XML (old style)

2. Create beans
@Component
class Engine {}

3. Resolve dependencies
@Component
class Car {
    private final Engine engine;

    Car(Engine engine) {} // dependency injected
}

4. Manage lifecycle
@PostConstruct
@PreDestroy
Scopes (singleton, prototype)

4Ô∏è‚É£ Types of IoC Containers in Spring
Container	Description
BeanFactory	Basic, lazy loading
ApplicationContext	Advanced, used in Spring Boot

üìå Spring Boot always uses ApplicationContext

6Ô∏è‚É£ Dependency Injection (DI) vs IoC
IoC
Principle (who controls object creation)
DI
Technique to implement IoC
Spring uses:
Constructor injection ‚úÖ
Setter injection
Field injection ‚ùå (not recommended)

7Ô∏è‚É£ Why IoC Container is Important
Without IoC:
Hard-coded dependencies
Poor testability
With IoC:
Loose coupling
Easy mocking
Cleaner architecture
Easier maintenance

9Ô∏è‚É£ Common Spring Annotations Related to IoC
| Annotation       | Purpose              |
| ---------------- | -------------------- |
| `@Component`     | Register bean        |
| `@Service`       | Business logic       |
| `@Repository`    | DB layer             |
| `@Controller`    | MVC                  |
| `@Autowired`     | Inject dependency    |
| `@Configuration` | Bean config          |
| `@Bean`          | Manual bean creation |

------------------------------------------------------------------------------------------

Q:- Difference between @Component and @Bean?
Core Difference (One Line)
@Component is used on a class
@Bean is used on a method

1Ô∏è‚É£ @Component
What it does
Marks a class as a Spring-managed bean
Discovered automatically via component scanning

Example
@Component
public class Engine {
}
Spring does:
Scan ‚Üí Detect ‚Üí Instantiate ‚Üí Manage

| Annotation    | Purpose           |
| ------------- | ----------------- |
| `@Component`  | Generic           |
| `@Service`    | Business logic    |
| `@Repository` | Persistence layer |
| `@Controller` | MVC               |

2Ô∏è‚É£ @Bean
What it does
Used on a method
Explicitly tells Spring how to create the object
Usually inside @Configuration class
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }
}
Spring does:
 Call method ‚Üí Get object ‚Üí Register as bean

| Feature               | `@Component`       | `@Bean`              |
| --------------------- | ------------------ | -------------------- |
| Applied to            | Class              | Method               |
| Discovery             | Component scanning | Explicit             |
| Control over creation | ‚ùå Limited          | ‚úÖ Full               |
| External libraries    | ‚ùå Cannot           | ‚úÖ Can                |
| Configuration logic   | ‚ùå No               | ‚úÖ Yes                |
| Typical use           | App classes        | Third-party / config |

4Ô∏è‚É£ When to Use @Component
‚úÖ When:
You own the class
Simple instantiation
No special setup required

5Ô∏è‚É£ When to Use @Bean
‚úÖ When:
Class is from third-party library
Requires custom initialization
Needs constructor parameters or logic

6Ô∏è‚É£ Important Subtle Differences ‚ö†Ô∏è
Bean Name
@Component
class MyService {}
Bean name ‚Üí myService

@Bean
public MyService customName() {}
Bean name ‚Üí customName

Lifecycle Callbacks
Both support:
@PostConstruct
@PreDestroy

Scope
Both support:
@Scope("prototype")

‚ùì Can @Bean exist without @Configuration?
‚úÖ Yes, but proxying is lost
Best practice: always use @Configuration

‚ùì Can @Component replace @Bean?
‚ùå No, especially for:
Third-party classes
Complex object creation

8Ô∏è‚É£ Real-world Analogy üß†
@Component
üè≠ Factory auto-produces standard parts
@Bean
üßë‚Äçüîß Custom-built part with manual steps

