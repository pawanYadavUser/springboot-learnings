1.- Explain Java OOPS with example in real life and in code.
OOPS Concepts in Java
Encapsulation ‚Üí Binding data (fields) and behavior (methods) into a single unit (class).
Inheritance ‚Üí One class (child) acquires properties & methods from another (parent).
Polymorphism ‚Üí Ability of an object/method to take many forms (method overloading & overriding).
Abstraction ‚Üí Hiding implementation details, showing only the essential features.

Real-life Example: Car
Encapsulation ‚Üí A car hides its internal engine mechanism but provides methods like accelerate(), brake().
Inheritance ‚Üí ElectricCar and DieselCar inherit from Car.
Polymorphism ‚Üí start() behaves differently for an ElectricCar (push button) vs DieselCar (ignition key).
Abstraction ‚Üí You just drive the car using the steering wheel, accelerator, and brake ‚Äî you don‚Äôt need to know how the engine works internally.

So in my projects, I use OOPs to design modular, maintainable, and reusable code. For example, services extend base classes,
entities encapsulate fields, and polymorphism helps in handling different request types flexibly
// Abstraction + Encapsulation
abstract class Car {
    private String brand;  // Encapsulation

    public Car(String brand) {
        this.brand = brand;
    }

    public String getBrand() {
        return brand;
    }

    // Abstract method -> Abstraction
    public abstract void start();
}
// Inheritance
class ElectricCar extends Car {
    public ElectricCar(String brand) {
        super(brand);
    }

    // Polymorphism (method overriding)
    @Override
    public void start() {
        System.out.println(getBrand() + " starts silently with a push button.");
    }
}
class DieselCar extends Car {
    public DieselCar(String brand) {
        super(brand);
    }

    @Override
    public void start() {
        System.out.println(getBrand() + " starts with ignition key and engine sound.");
    }
}
public class OOPSDemo {
    public static void main(String[] args) {
        // Polymorphism in action
        Car tesla = new ElectricCar("Tesla");
        Car ford = new DieselCar("Ford");

        tesla.start();  // Tesla starts silently with a push button.
        ford.start();   // Ford starts with ignition key and engine sound.
    }
}
‚úÖ In interviews, best way to answer:
So in my projects, I use OOPs to design modular, maintainable, and reusable code. For example, services extend base classes,
entities encapsulate fields, and polymorphism helps in handling different request types flexibly

----------------

2. - Is Java 100% object-oriented?
 Reasons why Java is not fully OOP:
 Primitive Data Types ‚Üí
 Java has 8 primitive types (int, char, boolean, float, double, long, short, byte).
 These are not objects (they are stored in stack memory, not heap).

 Static Methods & Variables ‚Üí
 static methods/variables (like main()) belong to a class, not an object, which breaks strict OOP.

 Wrapper Classes (Autoboxing) ‚Üí
 Java provides wrapper classes (Integer, Double, etc.) to use primitives as objects, but primitives themselves are still not objects.

 Java is object-oriented but not purely object-oriented.

 A pure OOP language would not have primitives (e.g., Smalltalk, Scala to some extent).
 üëâ So, in an interview you can reply:
 "Java is not 100% object-oriented because it supports primitive data types and static methods, which are not objects.
 However, through wrapper classes and autoboxing, primitives can behave like objects when needed."

-------------------
3. What are the basic classes in Java?
üìå Basic Classes in Java (java.lang package mainly)

Object
Root class of all Java classes.
Every class implicitly inherits from Object.
Provides methods like toString(), equals(), hashCode(), clone().

Wrapper Classes (for primitives ‚Üí objects)
Integer, Byte, Short, Long, Float, Double, Character, Boolean.
Used in collections (because collections store objects, not primitives).
Support autoboxing/unboxing.

String & StringBuffer / StringBuilder
String ‚Üí Immutable sequence of characters.
StringBuffer ‚Üí Mutable, thread-safe.
StringBuilder ‚Üí Mutable, faster (non-synchronized).

Math
Provides methods for mathematical operations (sqrt, pow, abs, sin, etc.).

System
Provides system-related utilities (System.out.println, System.gc(), etc.).

Class
Represents metadata of classes (used in Reflection API).

Throwable ‚Üí Exception & Error
Root of exception-handling hierarchy.
Exception ‚Üí Recoverable problems (e.g., IOException, SQLException).
Error ‚Üí Serious problems (e.g., OutOfMemoryError).

Thread (from java.lang and java.util.concurrent)
Represents a thread of execution.
Works with Runnable interface.

üìå Important Utility Classes (java.util package)
Collections Framework
ArrayList, HashMap, HashSet, LinkedList, TreeMap, etc.

Date & Time API
Legacy: Date, Calendar.
Modern (Java 8+): LocalDate, LocalTime, LocalDateTime, ZonedDateTime, etc.

------------------
3. What all methods are there in Object class?
‚úÖ Methods in Object class:

public final Class<?> getClass()
Returns the runtime class of the object.
Example: obj.getClass().getName()

public int hashCode()
Returns a hash code (used in hashing-based collections like HashMap, HashSet).

public boolean equals(Object obj)
Compares the current object with another for equality.
Can be overridden for custom equality logic.

protected Object clone() throws CloneNotSupportedException
Creates and returns a copy of the object (shallow copy).
Requires implementing Cloneable interface.

public String toString()
Returns a string representation of the object.
Default: className@hashCode.
Commonly overridden.

public final void notify()
Wakes up one thread waiting on this object‚Äôs monitor.
Related to synchronization.

public final void notifyAll()
Wakes up all threads waiting on this object‚Äôs monitor.

public final void wait()
Causes the current thread to wait until another thread invokes notify() or notifyAll().

public final void wait(long timeout)
Waits for a specified time (in milliseconds).

public final void wait(long timeout, int nanos)
Waits for the specified time with nanoseconds precision.

protected void finalize() throws Throwable
Called by the garbage collector before object destruction.
Deprecated in Java 9 (not recommended for use).

‚úÖ In summary:
Object Identity/Comparison ‚Üí equals(), hashCode()
Object Representation ‚Üí toString()
Object Copying ‚Üí clone()
Thread Synchronization ‚Üí wait(), notify(), notifyAll()
GC Hook ‚Üí finalize()

----------------------

4. - Final, finally and finalize?
1. final (keyword)
Used to declare constants, prevent inheritance, or prevent method overriding.
Usage:
Final variable ‚Üí Value cannot change.
final int MAX = 100;

Final method ‚Üí Cannot be overridden by child classes.
class Parent {
    final void show() { System.out.println("Hello"); }
}

Final class ‚Üí Cannot be subclassed.
final class MyClass {}

2. finally (block)
Used in exception handling to execute a block of code always, regardless of whether an exception occurs or not.
try {
    int a = 10/0;
} catch (ArithmeticException e) {
    System.out.println("Exception caught");
} finally {
    System.out.println("This always executes");
}
Commonly used for resource cleanup (closing files, DB connections).

3. finalize() (method)
  Called by the garbage collector before an object is destroyed.
  Lets you perform cleanup before the object is removed from memory.
  @Override
  protected void finalize() throws Throwable {
      System.out.println("Object is being garbage collected");
  }
Note: Deprecated in Java 9+, not recommended in modern Java.

------------------------------------

5. - Instance block, static block, anonymous block, constructor - How does the calling happen in Java. Explain RIWO
1Ô∏è‚É£ Static Block
Definition: Block of code inside a class marked with static { ... }.
Purpose: Initialize static variables or perform one-time setup.
Execution: Runs once, when the class is loaded into memory, before main() or any object creation.

2Ô∏è‚É£ Instance Block (Non-static block)
Definition: Block inside class without any keyword.
Purpose: Initialize instance variables.
Execution: Runs every time an object is created, before constructor.

3Ô∏è‚É£ Constructor
Definition: Special method with same name as class, no return type.
Purpose: Initialize object and assign values to instance variables.
Execution: Runs after instance block whenever object is created.

4Ô∏è‚É£ Anonymous Block
Usually refers to a non-static instance block (like the instance block above).
Runs every time object is created, before constructor.

5Ô∏è‚É£ Order of Execution (RIWO)
If you create a class like this:
class Demo {
    static {
        System.out.println("Static block");
    }

    {
        System.out.println("Instance block");
    }

    Demo() {
        System.out.println("Constructor");
    }

    public static void main(String[] args) {
        System.out.println("Main method starts");
        new Demo();
        new Demo();
    }
}
execution output:-
Static block        // executes once when class loads
Main method starts
Instance block      // for 1st object
Constructor         // for 1st object
Instance block      // for 2nd object
Constructor         // for 2nd object

‚úÖ Key Points
Static block ‚Üí Once when class loads.
Instance / Anonymous block ‚Üí Every object, before constructor.
Constructor ‚Üí Every object, after instance block.
Main method ‚Üí After class is loaded and static blocks executed

RIWO for Interview
If someone asks, ‚ÄúWhat runs first?‚Äù ‚Üí Static block ‚Üí Instance block ‚Üí Constructor ‚Üí main() (for object creation).

------------------

6. - Interface vs Abstract class explain with real life and code example and when to use each one of them?
1Ô∏è‚É£ Real-Life Analogy
Concept	Analogy
Interface	Like a remote control standard: Any device (TV, AC, Fan) that implements it must provide methods like turnOn() or turnOff().
You only care about the actions, not how they are done.
Abstract Class	Like a Vehicle blueprint: It can have some implemented features (like wheels, fuel type) and some abstract methods (like startEngine()).
Child classes (Car, Bike) inherit and complete the implementation.

2Ô∏è‚É£ Java Code Example
Interface Example
interface Remote {
    void turnOn();
    void turnOff();
}

class TV implements Remote {
    public void turnOn() {
        System.out.println("TV is ON");
    }
    public void turnOff() {
        System.out.println("TV is OFF");
    }
}

class Fan implements Remote {
    public void turnOn() {
        System.out.println("Fan is ON");
    }
    public void turnOff() {
        System.out.println("Fan is OFF");
    }
}
‚úÖ Key points:
Cannot have instance variables (before Java 8).
Only abstract methods (Java 8+ allows default and static methods).
Supports multiple inheritance.

Abstract Class Example
abstract class Vehicle {
    String fuelType = "Petrol";  // implemented feature

    abstract void startEngine();  // abstract method

    void displayFuel() {           // concrete method
        System.out.println("Fuel type: " + fuelType);
    }
}

class Car extends Vehicle {
    void startEngine() {
        System.out.println("Car engine started");
    }
}

class Bike extends Vehicle {
    void startEngine() {
        System.out.println("Bike engine started");
    }
}
‚úÖ Key points:
Can have both abstract and concrete methods.
Can have instance variables.
Supports single inheritance (only 1 parent class).

3Ô∏è‚É£ When to Use Each
Feature / Use Case	Interface	Abstract Class
Purpose	Define capabilities (what to do)	Define base class with partial implementation (what & how)
Methods	Only abstract (Java 7); default/static in Java 8+	Abstract + concrete
Variables	Only constants (static final)	Instance variables allowed
Inheritance	Multiple inheritance allowed	Single inheritance only
Example Scenario	‚ÄúAny device that can be turned on/off‚Äù	‚ÄúAll vehicles share fuel type and displayFuel(), but startEngine() differs‚Äù

Interview Tip
‚ÄúUse an interface when you want to define what a class can do without caring how.
Use an abstract class when you want to provide some shared functionality and leave some methods to be implemented by subclasses.‚Äù

--------------------------------

7. Where hashCode () is getting used in actual software dev?
hashCode() is one of those methods in Java that you rarely call directly in day-to-day coding, but it‚Äôs used heavily under the hood in real software development.

üîë Where hashCode() is actually used in real-world software dev:
1. Hash-based Collections (Most Common)
HashMap, HashSet, Hashtable
When you insert an object into a HashMap as a key:
Java calls hashCode() to find the bucket (index) in the hash table.
If multiple keys land in the same bucket, equals() is used to resolve collisions.

Map<Employee, String> empMap = new HashMap<>();
empMap.put(new Employee(101, "Pawan"), "Developer");

Employee.hashCode() decides which bucket the entry goes into.
If another Employee with same ID comes, equals() ensures it‚Äôs treated as the same key.

2. Caching
Many caching frameworks (like Ehcache, Caffeine, or even Spring Cache) use hash maps internally.
When caching an object by key, hashCode() is used to quickly locate that object.

3. ORM Frameworks (Hibernate, JPA)
Entities often end up in HashSet or HashMap inside the persistence context.
Hibernate may rely on hashCode() to track whether an entity is already managed.
That‚Äôs why it‚Äôs critical to override equals() and hashCode() correctly for entity classes.

4. Compiler & Runtime Internals
String.hashCode() is used everywhere:
Java intern pool.
When strings are stored in maps/sets (super common in real apps).
That‚Äôs why String.hashCode() is cached for performance.

8. what is bucket, what is collision , in relation to hashcode()?
ü™£ 1. What is a bucket?
Think of a HashMap like a giant cupboard with many boxes (buckets).
Each bucket is just a slot or container where entries can be stored.
When you put a key‚Äìvalue pair into a HashMap, Java doesn‚Äôt just put it anywhere. It calculates:
bucketIndex = hashCode(key) % numberOfBuckets
üëâ So hashCode() decides which bucket the key‚Äìvalue pair goes into.

Map<String, Integer> map = new HashMap<>();
map.put("Dog", 1);
map.put("Cat", 2);
map.put("Cow", 3);

Suppose hashCode("Dog") = 1009, hashCode("Cat") = 2008, hashCode("Cow") = 3017.
HashMap has (say) 16 buckets.
Then:
"Dog" ‚Üí 1009 % 16 = 1 ‚Üí goes into bucket #1
"Cat" ‚Üí 2008 % 16 = 8 ‚Üí goes into bucket #8
"Cow" ‚Üí 3017 % 16 = 1 ‚Üí goes into bucket #1
Now both "Dog" and "Cow" are in the same bucket. üëá That‚Äôs a collision.

üí• 2. What is a collision?
A collision happens when two different keys map to the same bucket.
Example above: "Dog" and "Cow" both ended up in bucket #1.
HashMap handles this using a LinkedList or Tree (since Java 8) inside each bucket:
If multiple keys go to the same bucket, Java stores them in a small list/tree inside that bucket.
When you search for a key, it goes to the correct bucket first (fast), then checks each item inside using equals().

üîé 3. Visual Example
HashMap with 4 buckets
[0] ‚Üí empty
[1] ‚Üí ("Dog", 1) ‚Üí ("Cow", 3)   // collision here
[2] ‚Üí empty
[3] ‚Üí ("Cat", 2)
"Dog" and "Cow" have different hashCode() values but after % 4, they both landed in bucket 1.
This is a collision. HashMap will then compare "Dog".equals("Cow") to distinguish them.

‚ö° Why it matters in real software?
If your hashCode() is badly written (e.g., always returns 1), then all keys will land in the same bucket ‚Üí
 HashMap becomes a LinkedList ‚Üí lookup is very slow (O(n) instead of O(1)).
A good hashCode() spreads keys across buckets evenly ‚Üí fast lookups.

üëâ In short:
Bucket = storage slot in HashMap where entries live.
Collision = when 2 different keys map to the same bucket.
hashCode() decides bucket; equals() decides if keys are actually the same.

---------------------------------------------------------------------------------------------

20/08/2025

1. What is a serializable , give example?
In Java, Serializable is a marker interface (java.io.Serializable) used to indicate that a class‚Äôs objects can be converted into a byte stream (serialization) and later
restored back into a copy of the object (deserialization).
This is useful when:
You want to save an object‚Äôs state to a file/database.
You want to send an object across a network (e.g., in distributed systems, RMI, sockets).
You want to cache objects in memory and restore them later.

üîπ Key Points
Serializable is a marker interface ‚Üí it has no methods.
Once a class implements Serializable, all its non-transient and non-static fields are serialized automatically.
transient keyword ‚Üí prevents a field from being serialized.
serialVersionUID is used to ensure version compatibility during deserialization.

e.g., SerializationExample.java
Notice that after deserialization, password is null because it was marked transient and thus not serialized.

‚úÖ In short:
Serialization = saving an object state into bytes.
Deserialization = reconstructing object from bytes.
Serializable is the interface that marks a class eligible for this process.

üéÆ Real-life Analogy: Saving a Video Game
Imagine you‚Äôre playing a game (say GTA).
Your character‚Äôs state (location, health, weapons, score, mission progress) is stored in memory while you‚Äôre playing.
If you quit the game without saving ‚Üí you lose progress.
If you save the game, the system takes a "snapshot" of your character‚Äôs state and writes it into a file.
Later, when you load the game, it restores your character exactly where you left off.
üëâ This is exactly what serialization (save) and deserialization (load) does in Java.

üîπ Mapping to Java
Game character = Java object (Student s1).
Save game = Serialize object ‚Üí write it into a file (student.ser).
Load game = Deserialize ‚Üí recreate object from the file.
transient fields = things not saved (e.g., temporary boosts or unsavable session data).
serialVersionUID = game version control (so an old save file works only if the new game version is compatible).

üåê Distributed Systems Analogy
Imagine two Java applications running on different machines:
App A: An e-commerce server.
App B: A payment service.
When App A wants to send a Java object (say, a PaymentRequest object) over the network to App B:
App A can‚Äôt just ship the object as-is (objects live in JVM memory, which is not shareable).
Instead, App A serializes the object into a byte stream.
The byte stream is sent over the network (TCP/HTTP/Message Queue etc.).
App B receives the byte stream and deserializes it back into the original Java object (PaymentRequest).

üìå Interview takeaway
Serialization is crucial for:
RMI (Remote Method Invocation)
Distributed caching (e.g., sending objects across nodes)
Messaging systems (Kafka, RabbitMQ, etc.)

-------------------------------------------------------

2. what are default & static methods in interface and their inheritance?
Default Methods in Interface
Introduced in Java 8.
Declared with the default keyword.
Provide a method body inside an interface (previously impossible).
Purpose: allow interface evolution without breaking old code (backward compatibility).

Static Methods in Interface
Also introduced in Java 8.
Declared with static keyword.
Can be called using the interface name only (not via implementing class/object).
Not inherited by implementing classes.

Inheritance Rules
(A) Default methods
1. Class wins over interface
If a class (or superclass) has a method with the same signature, it overrides the interface‚Äôs default method.
class Car {
    public void stop() {
        System.out.println("Car stopped");
    }
}

interface Vehicle {
    default void stop() { System.out.println("Vehicle stopped"); }
}

class Honda extends Car implements Vehicle {}
public class Test {
    public static void main(String[] args) {
        new Honda().stop();  // üëâ Output: "Car stopped" (class wins)
    }
}


2. Conflict resolution if multiple interfaces provide the same default method
If a class implements two interfaces with the same default method, the compiler forces you to override and resolve the conflict.
interface Vehicle {
    default void stop() { System.out.println("Vehicle stopped"); }
}

interface Machine {
    default void stop() { System.out.println("Machine stopped"); }
}

class Car implements Vehicle, Machine {
    @Override
    public void stop() {   // must override to resolve conflict
        System.out.println("Car stopped");
    }
}

B) Static methods
Not inherited by implementing class.
Always called with the interface name.
If two interfaces have static methods with the same name ‚Üí no conflict (since they are always called with interface name).
interface A {
    static void show() { System.out.println("A.show"); }
}

interface B {
    static void show() { System.out.println("B.show"); }
}

class Demo implements A, B {
    public void test() {
        // show();   // ‚ùå Not allowed
        A.show();    // ‚úÖ Calls A's static method
        B.show();    // ‚úÖ Calls B's static method
    }
}

‚úÖ Summary Table
Feature	Default Method	Static Method
Keyword	default	static
Inherited?	Yes (but overridden if class defines same method)	‚ùå No
Call syntax	object.method()	InterfaceName.method()
Purpose	Add new methods without breaking existing code	Utility/helper methods inside interface
Conflict?	Yes, if multiple interfaces define same method	No conflict (always tied to interface name)

‚ö° Golden Rule for Interview:
Class methods > Interface default methods.
Conflicting default methods ‚Üí must override.
Static methods in interfaces are not inherited.

3. what would happen if we dont override equals() and hashcode() method?
üîπ What happens if you don‚Äôt override equals() and hashCode()?
By default, every class in Java inherits these methods from Object

public boolean equals(Object obj) {
    return (this == obj);   // compares memory reference
}

public int hashCode() {
    return some unique integer for the object‚Äôs memory address
}

So:

equals() ‚Üí only returns true if both references point to the same object in memory.
hashCode() ‚Üí generates a unique integer based on memory location (not on actual object data)

So without overriding these methods,
üëâ Even though s1 and s2 have the same data, equals() returns false because it checks memory reference, not field values.
üëâ Hash codes are different because they‚Äôre tied to object identity.

üîπ Problem with Collections
If you add objects to a HashSet or HashMap without overriding equals() and hashCode(),
duplicates will not be detected.
HashSet<Student> set = new HashSet<>();
set.add(new Student(1, "Pawan"));
set.add(new Student(1, "Pawan"));
System.out.println(set.size());  // 2 ‚ùå (expected 1)


üîπ Correct way: Override both
‚úÖ Summary (Interview Answer)

If we don‚Äôt override equals() and hashCode(), object equality is based on reference (memory location), not data.
Collections like HashMap, HashSet, Hashtable will fail to work properly with duplicates.
To ensure logical equality (based on object state), we must override both equals() and hashCode().
4. What happens if you override only equals() but not hashCode()?
Java‚Äôs contract between equals() and hashCode() (from the Object class docs):
If two objects are equal (a.equals(b) == true), then they must have the same hashCode().
If two objects are not equal, they may or may not have different hash codes (collisions are allowed).
üëâ If you break this contract (by overriding equals() but not hashCode()), collections like HashMap, HashSet, Hashtable will misbehave.

Example: Overriding only equals()

import java.util.*;

class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // ‚úÖ equals overridden
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student s = (Student) o;
        return id == s.id && name.equals(s.name);
    }

   @override
    public boolean equals(Object o){
        if(this == o) return true;
        if (!(o instance of Student)) return false;
        Student s = (Student) o;
        return s.id == id && name.equals(s.name);

    }
    // ‚ùå hashCode NOT overridden
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student(1, "Pawan");
        Student s2 = new Student(1, "Pawan");

        System.out.println(s1.equals(s2)); // true ‚úÖ

        HashSet<Student> set = new HashSet<>();
        set.add(s1);
        set.add(s2);

        System.out.println(set.size()); // ‚ùå 2 (expected 1)
    }
}
üîπ Why did this happen?
HashSet uses hashCode() first to decide the bucket in the hash table.
Since s1 and s2 have different default hash codes (from memory location),
 they go into different buckets, even though equals() says they‚Äôre equal.
Result: Duplicates sneak in.

üîπ What if you override only hashCode() but not equals()?
üëâ Then objects with same data may have the same hash code,
 but since equals() still checks memory reference, duplicates won‚Äôt be detected eithe

 @Override
public int hashCode() {
    return Objects.hash(id, name);
}
// ‚ùå no equals()
s1.hashCode() == s2.hashCode(); // true
s1.equals(s2); // false
‚úÖ Correct Practice

üëâ Always override both equals() and hashCode() together.
This is why IDEs (like IntelliJ/Eclipse) generate them in pairs when you do Generate ‚Üí equals() and hashCode().

‚ö° Interview-ready one-liner:
If you override only equals() without hashCode(), c
collections like HashSet and HashMap will allow duplicates because the contract between equals() and hashCode()¬†is¬†broken.

