1.- Explain Java OOPS with example in real life and in code.
OOPS Concepts in Java
Encapsulation ‚Üí Binding data (fields) and behavior (methods) into a single unit (class).
Inheritance ‚Üí One class (child) acquires properties & methods from another (parent).
Polymorphism ‚Üí Ability of an object/method to take many forms (method overloading & overriding).
Abstraction ‚Üí Hiding implementation details, showing only the essential features.

Real-life Example: Car
Encapsulation ‚Üí A car hides its internal engine mechanism but provides methods like accelerate(), brake().
Inheritance ‚Üí ElectricCar and DieselCar inherit from Car.
Polymorphism ‚Üí start() behaves differently for an ElectricCar (push button) vs DieselCar (ignition key).
Abstraction ‚Üí You just drive the car using the steering wheel, accelerator, and brake ‚Äî you don‚Äôt need to know how the engine works internally.

So in my projects, I use OOPs to design modular, maintainable, and reusable code. For example, services extend base classes,
entities encapsulate fields, and polymorphism helps in handling different request types flexibly
// Abstraction + Encapsulation
abstract class Car {
    private String brand;  // Encapsulation

    public Car(String brand) {
        this.brand = brand;
    }

    public String getBrand() {
        return brand;
    }

    // Abstract method -> Abstraction
    public abstract void start();
}
// Inheritance
class ElectricCar extends Car {
    public ElectricCar(String brand) {
        super(brand);
    }

    // Polymorphism (method overriding)
    @Override
    public void start() {
        System.out.println(getBrand() + " starts silently with a push button.");
    }
}
class DieselCar extends Car {
    public DieselCar(String brand) {
        super(brand);
    }

    @Override
    public void start() {
        System.out.println(getBrand() + " starts with ignition key and engine sound.");
    }
}
public class OOPSDemo {
    public static void main(String[] args) {
        // Polymorphism in action
        Car tesla = new ElectricCar("Tesla");
        Car ford = new DieselCar("Ford");

        tesla.start();  // Tesla starts silently with a push button.
        ford.start();   // Ford starts with ignition key and engine sound.
    }
}
‚úÖ In interviews, best way to answer:
So in my projects, I use OOPs to design modular, maintainable, and reusable code. For example, services extend base classes,
entities encapsulate fields, and polymorphism helps in handling different request types flexibly

----------------

2. - Is Java 100% object-oriented?
 Reasons why Java is not fully OOP:
 Primitive Data Types ‚Üí
 Java has 8 primitive types (int, char, boolean, float, double, long, short, byte).
 These are not objects (they are stored in stack memory, not heap).

 Static Methods & Variables ‚Üí
 static methods/variables (like main()) belong to a class, not an object, which breaks strict OOP.

 Wrapper Classes (Autoboxing) ‚Üí
 Java provides wrapper classes (Integer, Double, etc.) to use primitives as objects, but primitives themselves are still not objects.

 Java is object-oriented but not purely object-oriented.

 A pure OOP language would not have primitives (e.g., Smalltalk, Scala to some extent).
 üëâ So, in an interview you can reply:
 "Java is not 100% object-oriented because it supports primitive data types and static methods, which are not objects.
 However, through wrapper classes and autoboxing, primitives can behave like objects when needed."

-------------------
3. What are the basic classes in Java?
üìå Basic Classes in Java (java.lang package mainly)

Object
Root class of all Java classes.
Every class implicitly inherits from Object.
Provides methods like toString(), equals(), hashCode(), clone().

Wrapper Classes (for primitives ‚Üí objects)
Integer, Byte, Short, Long, Float, Double, Character, Boolean.
Used in collections (because collections store objects, not primitives).
Support autoboxing/unboxing.

String & StringBuffer / StringBuilder
String ‚Üí Immutable sequence of characters.
StringBuffer ‚Üí Mutable, thread-safe.
StringBuilder ‚Üí Mutable, faster (non-synchronized).

Math
Provides methods for mathematical operations (sqrt, pow, abs, sin, etc.).

System
Provides system-related utilities (System.out.println, System.gc(), etc.).

Class
Represents metadata of classes (used in Reflection API).

Throwable ‚Üí Exception & Error
Root of exception-handling hierarchy.
Exception ‚Üí Recoverable problems (e.g., IOException, SQLException).
Error ‚Üí Serious problems (e.g., OutOfMemoryError).

Thread (from java.lang and java.util.concurrent)
Represents a thread of execution.
Works with Runnable interface.

üìå Important Utility Classes (java.util package)
Collections Framework
ArrayList, HashMap, HashSet, LinkedList, TreeMap, etc.

Date & Time API
Legacy: Date, Calendar.
Modern (Java 8+): LocalDate, LocalTime, LocalDateTime, ZonedDateTime, etc.

------------------
3. What all methods are there in Object class?
‚úÖ Methods in Object class:

public final Class<?> getClass()
Returns the runtime class of the object.
Example: obj.getClass().getName()

public int hashCode()
Returns a hash code (used in hashing-based collections like HashMap, HashSet).

public boolean equals(Object obj)
Compares the current object with another for equality.
Can be overridden for custom equality logic.

protected Object clone() throws CloneNotSupportedException
Creates and returns a copy of the object (shallow copy).
Requires implementing Cloneable interface.

public String toString()
Returns a string representation of the object.
Default: className@hashCode.
Commonly overridden.

public final void notify()
Wakes up one thread waiting on this object‚Äôs monitor.
Related to synchronization.

public final void notifyAll()
Wakes up all threads waiting on this object‚Äôs monitor.

public final void wait()
Causes the current thread to wait until another thread invokes notify() or notifyAll().

public final void wait(long timeout)
Waits for a specified time (in milliseconds).

public final void wait(long timeout, int nanos)
Waits for the specified time with nanoseconds precision.

protected void finalize() throws Throwable
Called by the garbage collector before object destruction.
Deprecated in Java 9 (not recommended for use).

‚úÖ In summary:
Object Identity/Comparison ‚Üí equals(), hashCode()
Object Representation ‚Üí toString()
Object Copying ‚Üí clone()
Thread Synchronization ‚Üí wait(), notify(), notifyAll()
GC Hook ‚Üí finalize()

----------------------

4. - Final, finally and finalize?
1. final (keyword)
Used to declare constants, prevent inheritance, or prevent method overriding.
Usage:
Final variable ‚Üí Value cannot change.
final int MAX = 100;

Final method ‚Üí Cannot be overridden by child classes.
class Parent {
    final void show() { System.out.println("Hello"); }
}

Final class ‚Üí Cannot be subclassed.
final class MyClass {}

2. finally (block)
Used in exception handling to execute a block of code always, regardless of whether an exception occurs or not.
try {
    int a = 10/0;
} catch (ArithmeticException e) {
    System.out.println("Exception caught");
} finally {
    System.out.println("This always executes");
}
Commonly used for resource cleanup (closing files, DB connections).

3. finalize() (method)
  Called by the garbage collector before an object is destroyed.
  Lets you perform cleanup before the object is removed from memory.
  @Override
  protected void finalize() throws Throwable {
      System.out.println("Object is being garbage collected");
  }
Note: Deprecated in Java 9+, not recommended in modern Java.

------------------------------------

5. - Instance block, static block, anonymous block, constructor - How does the calling happen in Java. Explain RIWO
1Ô∏è‚É£ Static Block
Definition: Block of code inside a class marked with static { ... }.
Purpose: Initialize static variables or perform one-time setup.
Execution: Runs once, when the class is loaded into memory, before main() or any object creation.

2Ô∏è‚É£ Instance Block (Non-static block)
Definition: Block inside class without any keyword.
Purpose: Initialize instance variables.
Execution: Runs every time an object is created, before constructor.

3Ô∏è‚É£ Constructor
Definition: Special method with same name as class, no return type.
Purpose: Initialize object and assign values to instance variables.
Execution: Runs after instance block whenever object is created.

4Ô∏è‚É£ Anonymous Block
Usually refers to a non-static instance block (like the instance block above).
Runs every time object is created, before constructor.

5Ô∏è‚É£ Order of Execution (RIWO)
If you create a class like this:
class Demo {
    static {
        System.out.println("Static block");
    }

    {
        System.out.println("Instance block");
    }

    Demo() {
        System.out.println("Constructor");
    }

    public static void main(String[] args) {
        System.out.println("Main method starts");
        new Demo();
        new Demo();
    }
}
execution output:-
Static block        // executes once when class loads
Main method starts
Instance block      // for 1st object
Constructor         // for 1st object
Instance block      // for 2nd object
Constructor         // for 2nd object

‚úÖ Key Points
Static block ‚Üí Once when class loads.
Instance / Anonymous block ‚Üí Every object, before constructor.
Constructor ‚Üí Every object, after instance block.
Main method ‚Üí After class is loaded and static blocks executed

RIWO for Interview
If someone asks, ‚ÄúWhat runs first?‚Äù ‚Üí Static block ‚Üí Instance block ‚Üí Constructor ‚Üí main() (for object creation).

------------------

6. - Interface vs Abstract class explain with real life and code example and when to use each one of them?
1Ô∏è‚É£ Real-Life Analogy
Concept	Analogy
Interface	Like a remote control standard: Any device (TV, AC, Fan) that implements it must provide methods like turnOn() or turnOff().
You only care about the actions, not how they are done.
Abstract Class	Like a Vehicle blueprint: It can have some implemented features (like wheels, fuel type) and some abstract methods (like startEngine()).
Child classes (Car, Bike) inherit and complete the implementation.

2Ô∏è‚É£ Java Code Example
Interface Example
interface Remote {
    void turnOn();
    void turnOff();
}

class TV implements Remote {
    public void turnOn() {
        System.out.println("TV is ON");
    }
    public void turnOff() {
        System.out.println("TV is OFF");
    }
}

class Fan implements Remote {
    public void turnOn() {
        System.out.println("Fan is ON");
    }
    public void turnOff() {
        System.out.println("Fan is OFF");
    }
}
‚úÖ Key points:
Cannot have instance variables (before Java 8).
Only abstract methods (Java 8+ allows default and static methods).
Supports multiple inheritance.

Abstract Class Example
abstract class Vehicle {
    String fuelType = "Petrol";  // implemented feature

    abstract void startEngine();  // abstract method

    void displayFuel() {           // concrete method
        System.out.println("Fuel type: " + fuelType);
    }
}

class Car extends Vehicle {
    void startEngine() {
        System.out.println("Car engine started");
    }
}

class Bike extends Vehicle {
    void startEngine() {
        System.out.println("Bike engine started");
    }
}
‚úÖ Key points:
Can have both abstract and concrete methods.
Can have instance variables.
Supports single inheritance (only 1 parent class).

3Ô∏è‚É£ When to Use Each
Feature / Use Case	Interface	Abstract Class
Purpose	Define capabilities (what to do)	Define base class with partial implementation (what & how)
Methods	Only abstract (Java 7); default/static in Java 8+	Abstract + concrete
Variables	Only constants (static final)	Instance variables allowed
Inheritance	Multiple inheritance allowed	Single inheritance only
Example Scenario	‚ÄúAny device that can be turned on/off‚Äù	‚ÄúAll vehicles share fuel type and displayFuel(), but startEngine() differs‚Äù

Interview Tip
‚ÄúUse an interface when you want to define what a class can do without caring how.
Use an abstract class when you want to provide some shared functionality and leave some methods to be implemented by subclasses.‚Äù

--------------------------------

7. Where hashCode () is getting used in actual software dev?
hashCode() is one of those methods in Java that you rarely call directly in day-to-day coding, but it‚Äôs used heavily under the hood in real software development.

üîë Where hashCode() is actually used in real-world software dev:
1. Hash-based Collections (Most Common)
HashMap, HashSet, Hashtable
When you insert an object into a HashMap as a key:
Java calls hashCode() to find the bucket (index) in the hash table.
If multiple keys land in the same bucket, equals() is used to resolve collisions.

Map<Employee, String> empMap = new HashMap<>();
empMap.put(new Employee(101, "Pawan"), "Developer");

Employee.hashCode() decides which bucket the entry goes into.
If another Employee with same ID comes, equals() ensures it‚Äôs treated as the same key.

2. Caching
Many caching frameworks (like Ehcache, Caffeine, or even Spring Cache) use hash maps internally.
When caching an object by key, hashCode() is used to quickly locate that object.

3. ORM Frameworks (Hibernate, JPA)
Entities often end up in HashSet or HashMap inside the persistence context.
Hibernate may rely on hashCode() to track whether an entity is already managed.
That‚Äôs why it‚Äôs critical to override equals() and hashCode() correctly for entity classes.

4. Compiler & Runtime Internals
String.hashCode() is used everywhere:
Java intern pool.
When strings are stored in maps/sets (super common in real apps).
That‚Äôs why String.hashCode() is cached for performance.

8. what is bucket, what is collision , in relation to hashcode()?
ü™£ 1. What is a bucket?
Think of a HashMap like a giant cupboard with many boxes (buckets).
Each bucket is just a slot or container where entries can be stored.
When you put a key‚Äìvalue pair into a HashMap, Java doesn‚Äôt just put it anywhere. It calculates:
bucketIndex = hashCode(key) % numberOfBuckets
üëâ So hashCode() decides which bucket the key‚Äìvalue pair goes into.

Map<String, Integer> map = new HashMap<>();
map.put("Dog", 1);
map.put("Cat", 2);
map.put("Cow", 3);

Suppose hashCode("Dog") = 1009, hashCode("Cat") = 2008, hashCode("Cow") = 3017.
HashMap has (say) 16 buckets.
Then:
"Dog" ‚Üí 1009 % 16 = 1 ‚Üí goes into bucket #1
"Cat" ‚Üí 2008 % 16 = 8 ‚Üí goes into bucket #8
"Cow" ‚Üí 3017 % 16 = 1 ‚Üí goes into bucket #1
Now both "Dog" and "Cow" are in the same bucket. üëá That‚Äôs a collision.

üí• 2. What is a collision?
A collision happens when two different keys map to the same bucket.
Example above: "Dog" and "Cow" both ended up in bucket #1.
HashMap handles this using a LinkedList or Tree (since Java 8) inside each bucket:
If multiple keys go to the same bucket, Java stores them in a small list/tree inside that bucket.
When you search for a key, it goes to the correct bucket first (fast), then checks each item inside using equals().

üîé 3. Visual Example
HashMap with 4 buckets
[0] ‚Üí empty
[1] ‚Üí ("Dog", 1) ‚Üí ("Cow", 3)   // collision here
[2] ‚Üí empty
[3] ‚Üí ("Cat", 2)
"Dog" and "Cow" have different hashCode() values but after % 4, they both landed in bucket 1.
This is a collision. HashMap will then compare "Dog".equals("Cow") to distinguish them.

‚ö° Why it matters in real software?
If your hashCode() is badly written (e.g., always returns 1), then all keys will land in the same bucket ‚Üí
 HashMap becomes a LinkedList ‚Üí lookup is very slow (O(n) instead of O(1)).
A good hashCode() spreads keys across buckets evenly ‚Üí fast lookups.

üëâ In short:
Bucket = storage slot in HashMap where entries live.
Collision = when 2 different keys map to the same bucket.
hashCode() decides bucket; equals() decides if keys are actually the same.

---------------------------------------------------------------------------------------------

20/08/2025

1. What is a serializable , give example?
In Java, Serializable is a marker interface (java.io.Serializable) used to indicate that a class‚Äôs objects can be converted into a byte stream (serialization) and later
restored back into a copy of the object (deserialization).
This is useful when:
You want to save an object‚Äôs state to a file/database.
You want to send an object across a network (e.g., in distributed systems, RMI, sockets).
You want to cache objects in memory and restore them later.

üîπ Key Points
Serializable is a marker interface ‚Üí it has no methods.
Once a class implements Serializable, all its non-transient and non-static fields are serialized automatically.
transient keyword ‚Üí prevents a field from being serialized.
serialVersionUID is used to ensure version compatibility during deserialization.

e.g., SerializationExample.java
Notice that after deserialization, password is null because it was marked transient and thus not serialized.

‚úÖ In short:
Serialization = saving an object state into bytes.
Deserialization = reconstructing object from bytes.
Serializable is the interface that marks a class eligible for this process.

üéÆ Real-life Analogy: Saving a Video Game
Imagine you‚Äôre playing a game (say GTA).
Your character‚Äôs state (location, health, weapons, score, mission progress) is stored in memory while you‚Äôre playing.
If you quit the game without saving ‚Üí you lose progress.
If you save the game, the system takes a "snapshot" of your character‚Äôs state and writes it into a file.
Later, when you load the game, it restores your character exactly where you left off.
üëâ This is exactly what serialization (save) and deserialization (load) does in Java.

üîπ Mapping to Java
Game character = Java object (Student s1).
Save game = Serialize object ‚Üí write it into a file (student.ser).
Load game = Deserialize ‚Üí recreate object from the file.
transient fields = things not saved (e.g., temporary boosts or unsavable session data).
serialVersionUID = game version control (so an old save file works only if the new game version is compatible).

üåê Distributed Systems Analogy
Imagine two Java applications running on different machines:
App A: An e-commerce server.
App B: A payment service.
When App A wants to send a Java object (say, a PaymentRequest object) over the network to App B:
App A can‚Äôt just ship the object as-is (objects live in JVM memory, which is not shareable).
Instead, App A serializes the object into a byte stream.
The byte stream is sent over the network (TCP/HTTP/Message Queue etc.).
App B receives the byte stream and deserializes it back into the original Java object (PaymentRequest).

üìå Interview takeaway
Serialization is crucial for:
RMI (Remote Method Invocation)
Distributed caching (e.g., sending objects across nodes)
Messaging systems (Kafka, RabbitMQ, etc.)

-------------------------------------------------------

2. what are default & static methods in interface and their inheritance?
Default Methods in Interface
Introduced in Java 8.
Declared with the default keyword.
Provide a method body inside an interface (previously impossible).
Purpose: allow interface evolution without breaking old code (backward compatibility).

Static Methods in Interface
Also introduced in Java 8.
Declared with static keyword.
Can be called using the interface name only (not via implementing class/object).
Not inherited by implementing classes.

Inheritance Rules
(A) Default methods
1. Class wins over interface
If a class (or superclass) has a method with the same signature, it overrides the interface‚Äôs default method.
class Car {
    public void stop() {
        System.out.println("Car stopped");
    }
}

interface Vehicle {
    default void stop() { System.out.println("Vehicle stopped"); }
}

class Honda extends Car implements Vehicle {}
public class Test {
    public static void main(String[] args) {
        new Honda().stop();  // üëâ Output: "Car stopped" (class wins)
    }
}


2. Conflict resolution if multiple interfaces provide the same default method
If a class implements two interfaces with the same default method, the compiler forces you to override and resolve the conflict.
interface Vehicle {
    default void stop() { System.out.println("Vehicle stopped"); }
}

interface Machine {
    default void stop() { System.out.println("Machine stopped"); }
}

class Car implements Vehicle, Machine {
    @Override
    public void stop() {   // must override to resolve conflict
        System.out.println("Car stopped");
    }
}

B) Static methods
Not inherited by implementing class.
Always called with the interface name.
If two interfaces have static methods with the same name ‚Üí no conflict (since they are always called with interface name).
interface A {
    static void show() { System.out.println("A.show"); }
}

interface B {
    static void show() { System.out.println("B.show"); }
}

class Demo implements A, B {
    public void test() {
        // show();   // ‚ùå Not allowed
        A.show();    // ‚úÖ Calls A's static method
        B.show();    // ‚úÖ Calls B's static method
    }
}

‚úÖ Summary Table
Feature	Default Method	Static Method
Keyword	default	static
Inherited?	Yes (but overridden if class defines same method)	‚ùå No
Call syntax	object.method()	InterfaceName.method()
Purpose	Add new methods without breaking existing code	Utility/helper methods inside interface
Conflict?	Yes, if multiple interfaces define same method	No conflict (always tied to interface name)

‚ö° Golden Rule for Interview:
Class methods > Interface default methods.
Conflicting default methods ‚Üí must override.
Static methods in interfaces are not inherited.

3. what would happen if we dont override equals() and hashcode() method?
üîπ What happens if you don‚Äôt override equals() and hashCode()?
By default, every class in Java inherits these methods from Object

public boolean equals(Object obj) {
    return (this == obj);   // compares memory reference
}

public int hashCode() {
    return some unique integer for the object‚Äôs memory address
}

So:

equals() ‚Üí only returns true if both references point to the same object in memory.
hashCode() ‚Üí generates a unique integer based on memory location (not on actual object data)

So without overriding these methods,
üëâ Even though s1 and s2 have the same data, equals() returns false because it checks memory reference, not field values.
üëâ Hash codes are different because they‚Äôre tied to object identity.

üîπ Problem with Collections
If you add objects to a HashSet or HashMap without overriding equals() and hashCode(),
duplicates will not be detected.
HashSet<Student> set = new HashSet<>();
set.add(new Student(1, "Pawan"));
set.add(new Student(1, "Pawan"));
System.out.println(set.size());  // 2 ‚ùå (expected 1)


üîπ Correct way: Override both
‚úÖ Summary (Interview Answer)

If we don‚Äôt override equals() and hashCode(), object equality is based on reference (memory location), not data.
Collections like HashMap, HashSet, Hashtable will fail to work properly with duplicates.
To ensure logical equality (based on object state), we must override both equals() and hashCode().
4. What happens if you override only equals() but not hashCode()?
Java‚Äôs contract between equals() and hashCode() (from the Object class docs):
If two objects are equal (a.equals(b) == true), then they must have the same hashCode().
If two objects are not equal, they may or may not have different hash codes (collisions are allowed).
üëâ If you break this contract (by overriding equals() but not hashCode()), collections like HashMap, HashSet, Hashtable will misbehave.

Example: Overriding only equals()

import java.util.*;

class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // ‚úÖ equals overridden
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student s = (Student) o;
        return id == s.id && name.equals(s.name);
    }

   @override
    public boolean equals(Object o){
        if(this == o) return true;
        if (!(o instance of Student)) return false;
        Student s = (Student) o;
        return s.id == id && name.equals(s.name);

    }
    // ‚ùå hashCode NOT overridden
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student(1, "Pawan");
        Student s2 = new Student(1, "Pawan");

        System.out.println(s1.equals(s2)); // true ‚úÖ

        HashSet<Student> set = new HashSet<>();
        set.add(s1);
        set.add(s2);

        System.out.println(set.size()); // ‚ùå 2 (expected 1)
    }
}
üîπ Why did this happen?
HashSet uses hashCode() first to decide the bucket in the hash table.
Since s1 and s2 have different default hash codes (from memory location),
 they go into different buckets, even though equals() says they‚Äôre equal.
Result: Duplicates sneak in.

üîπ What if you override only hashCode() but not equals()?
üëâ Then objects with same data may have the same hash code,
 but since equals() still checks memory reference, duplicates won‚Äôt be detected eithe

 @Override
public int hashCode() {
    return Objects.hash(id, name);
}
// ‚ùå no equals()
s1.hashCode() == s2.hashCode(); // true
s1.equals(s2); // false
‚úÖ Correct Practice

üëâ Always override both equals() and hashCode() together.
This is why IDEs (like IntelliJ/Eclipse) generate them in pairs when you do Generate ‚Üí equals() and hashCode().

‚ö° Interview-ready one-liner:
If you override only equals() without hashCode(), c
collections like HashSet and HashMap will allow duplicates because the contract between equals() and hashCode()¬†is¬†broken.

-------------------------------------------------------------------------------------------------------------------------------------------

1. map vs flatmap
üîπ 1. What is flatMap?
map() ‚Üí transforms each element into one output.
flatMap() ‚Üí transforms each element into a Stream of outputs, then flattens (merges) all those streams into one big stream.
Think:
üëâ map = 1-to-1
üëâ flatMap = 1-to-many, then flattened

üîπ 2. Example without flatMap
Suppose you have a list of sentences:
List<String> sentences = Arrays.asList("I love Java", "Streams are cool");
using map:
List<String[]> result = sentences.stream()
                                 .map(s -> s.split(" "))
                                 .toList();

Now result is a List of String[] (a nested structure):
[ ["I", "love", "Java"], ["Streams", "are", "cool"] ]  #########  stream of list of string

üîπ 3. With flatMap
List<String> words = sentences.stream()
                              .flatMap(s -> Arrays.stream(s.split(" ")))
                              .toList();
Output:
["I", "love", "Java", "Streams", "are", "cool"] ##########  stream of string
‚ú® Notice how the nested arrays are flattened into a single list of words.

In short, we can say that if there is a Stream of List of <Data Type> before flattening, then on applying flatMap(),
Stream of <Data Type> is returned after flattening.

---------------------------------------------------------------

what why and how concurrent modification exception?
modecount?
concurrent hashmpap vs normal hashmap?
copyOnWriteArray vs normal array?
synchronised map vs concurrent hashmap?
compare and swap?

Queues and stack implementation using linkedlist?
set implementation in java?
hashset impln in java?


when it is called and when it is not? finalise().
deprecation in java and its alternative in java?

Memory model?

Bean storage in JVM?

Meta space (new version)

How many null key are allowed in hashmap?

------------------------------------------------------------------------------------------

1. What is Autoboxing?
Autoboxing is the automatic conversion performed by the Java compiler between a primitive type and its
corresponding wrapper class.
Example:
int num = 5;
Integer boxed = num;   // Autoboxing: int ‚Üí Integer

2. What is Unboxing?
Unboxing is the reverse process where a wrapper class object is automatically converted into its corresponding primitive type.
Example:
Integer boxed = 10;
int num = boxed;   // Unboxing: Integer ‚Üí int

3. Why was Autoboxing introduced?
Before Java 5, you had to manually convert between primitives and wrapper classes.
Integer i = new Integer(5);   // before Java 5
int x = i.intValue();         // manual unboxing
With autoboxing/unboxing (Java 5+), the compiler does it automatically, making code cleaner and less error-prone.

4. Example in Collections (where autoboxing shines):
Collections like ArrayList can only store objects, not primitives.
List<Integer> list = new ArrayList<>();
list.add(5);         // int ‚Üí Integer (autoboxing)
int val = list.get(0); // Integer ‚Üí int (unboxing)

5. Common Interview Traps with Autoboxing
(a) Performance Issue
Autoboxing creates extra objects ‚Üí can cause memory overhead in large loops.
Long sum = 0L;
for (long i = 0; i < 1000000; i++) {
    sum += i;   // Autoboxing & unboxing inside loop ‚Üí performance hit
}
üëâ Fix: use primitive long sum = 0;

(b) NullPointerException with Unboxing
Integer num = null;
int val = num;  // Throws NullPointerException during unboxing
üëâ Always check for null before unboxing.

(c) Equality Confusion
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true (cached values -128 to 127)

Integer x = 200;
Integer y = 200;
System.out.println(x == y); // false (different objects)
üëâ Use .equals() to compare wrapper objects, not ==.

When you write Integer a = 100;, Java automatically converts the primitive int (100) into an Integer object.
This is called autoboxing

Integer Cache
Java maintains a cache of Integer objects for values from -128 to 127.
This means whenever you autobox a value in that range, Java reuses the same object from the cache instead of creating a new one.
Integer a = 100;
Integer b = 100;
Both a and b point to the same cached object (since 100 is within -128 to 127).
a == b  // true (same reference)

Outside the Cache
For values outside -128 to 127, Java does not reuse cached objects.
Instead, it creates a new object each time.
Integer x = 200;
Integer y = 200;

Both x and y are different objects (since 200 is outside the cache).
So:
x == y  // false (different references)

Key takeaway
== compares references (memory address), not values.
.equals() compares the values inside the object.
So:
System.out.println(x.equals(y)); // true
because both x and y hold the value 200.

‚úÖ Summary
== ‚Üí compares object references.
.equals() ‚Üí compares object values.
Autoboxed integers from -128 to 127 are cached and reused

‚úÖ In summary:
Autoboxing = primitive ‚Üí wrapper automatically.
Unboxing = wrapper ‚Üí primitive automatically.
Pros: Cleaner code, easier collection handling.
Cons: Performance issues & NullPointerException risk.

-------------------------------------------------------------------------------------------------

JVM memory model

1. What are the different memory areas allocated by JVM?
Heap ‚Äì Stores objects and instance variables. Managed by Garbage Collector.
he Heap is typically divided into two main areas: The Young Generation and the Old Generation (also known as the Tenured Generation).
The Young Generation is further divided into the Eden Space and Survivor Spaces,
while the Old Generation contains long-lived objects that have survived multiple garbage collection cycles.

Stack ‚Äì Stores method calls, local variables, and references. Each thread has its own stack.
Method Area (Metaspace in Java 8+) ‚Äì Stores class metadata, static variables, and method code.
PC Register ‚Äì Holds the current instruction address of a thread.
Native Method Stack ‚Äì Used for native (C/C++) method calls.

2. What is the difference between stack memory and heap memory?
Stack: Thread-local, faster, stores primitives and references.
Heap: Shared across threads, slower, stores actual objects.

3. What is the role of the Garbage Collector in JVM?
GC reclaims memory by removing objects that are no longer referenced, preventing memory leaks.

4. What is a memory leak in Java?
A memory leak occurs when objects are no longer used but still referenced (e.g., stored in a static collection), preventing GC from reclaiming them.
give its example?

5. What is OutOfMemoryError in Java?
Thrown when JVM cannot allocate memory for new objects, even after GC. Example: java.lang.OutOfMemoryError: Java heap space.

6. What is StackOverflowError in Java?
Occurs when stack memory is exhausted, typically due to deep or infinite recursion.

7. What is the difference between final, finally, and finalize()?
final: Keyword for constants, preventing inheritance or method overriding.
finally: Block in try-catch used for cleanup.
finalize(): Method called before GC deletes an object (not reliable).

8. What is the difference between strong, weak, soft, and phantom references?
Strong: Normal references, prevent GC.
Weak: Collected when no strong refs exist (WeakHashMap).
Soft: GC removes them only when memory is low (good for caches).
Phantom: Used to track object finalization before GC.
??????
search more

9. How is String stored in memory?
Strings are stored in the Heap. Literal strings go into the String pool inside the Method Area/Metaspace.

10. Difference between PermGen and Metaspace?
PermGen (till Java 7): Fixed size, stored class metadata.
Metaspace (Java 8+): Resides in native memory, grows dynamically.

11. How to tune JVM memory?
Use JVM options:
-Xms ‚Üí initial heap size
-Xmx ‚Üí max heap size
-Xss ‚Üí stack size per thread
-XX:MaxMetaspaceSize ‚Üí max Metaspace size

12. What is memory fragmentation in Java?
When free memory is available but in non-contiguous blocks, making large allocations fail. JVM GC compacts memory to reduce fragmentation.

13. How does Garbage Collector decide which objects to collect?
GC uses reachability analysis (object graph traversal).
Objects not reachable from GC roots (stack references, static variables, JNI references) are eligible for collection.
example?

14. What are Stop-the-World events?
GC pauses all application threads while it reclaims memory, leading to performance impact.

15. What is difference between Minor GC and Major GC?
Minor GC: Cleans Young Generation (fast, frequent).
Major/Full GC: Cleans Old Generation and sometimes entire heap (slower).

16. What is the difference between Serial, Parallel, CMS, and G1 GC?
Serial GC: Single-threaded, simple, best for small apps.
Parallel GC: Multi-threaded, throughput focused.
CMS (Concurrent Mark-Sweep): Low pause times, concurrent collection.
G1 GC: Region-based, balances throughput and low-latency (default in Java 9+).
more r & d?

17. What is a memory barrier in Java?
A memory barrier (or fence) is a JVM instruction that prevents reordering of reads/writes,
ensuring thread visibility (used in volatile variables).

18. What happens when you call System.gc()?
It requests GC, but does not guarantee immediate collection. JVM decides when to run GC.

19. How do you monitor memory usage in Java?
  Tools: jconsole, jvisualvm, jmap, jstat
  Code: Runtime.getRuntime().totalMemory(), freeMemory(), maxMemory()

20. How do you prevent memory leaks in Java applications?
Close resources (files, DB connections, sockets).
Use weak references for caches.
Avoid static collections holding large objects.
Use profiling tools to detect leaks.

-----------------------------------------------------------------------------------

To the new interview new topics to be done!

31/08/2025
1. Hash table!
Different hashing techniques, like division hashing, multiplicative hashing, and advanced methods like double hashing or chaining, spread keys more uniformly,
which reduces collisions and improves overall hash table efficiency.
Better hash functions and algorithms mean fewer collisions, leading to consistently faster lookups and updates in practice.

2. Single linked list VS double linked list!
A doubly linked list has nodes with pointers to both next and previous nodes, allowing bidirectional traversal, while a singly linked list only has next pointers,
supporting one-way traversal. Doubly linked lists are preferred when frequent insertion, deletion,
or navigation in both directions is needed; singly linked lists are ideal when memory efficiency and simple forward-only traversal suffice.

Singly Linked List preferred when:
   Memory usage is critical, as it uses less memory per node.
   Data is primarily accessed sequentially in one direction (e.g., simple queues, stacks).
   Implementing simple traversal with less overhead is sufficient.
Doubly Linked List preferred when:
   Frequent insertions and deletions occur at both ends (e.g., deques).
   Bidirectional traversal is needed (e.g., navigation in browsers, undo functionality).
   Complex data structures require backtracking or two-way iteration (e.g., certain tree or graph implementations).

Two-way traversal in doubly linked lists lets insertion and deletion at both ends or any position happen more efficiently,
since each node knows its previous and next nodes; this allows removals without needing a full traversal as required in singly linked lists.
Deletion or insertion at a specific location is
O(1)
O(1) if a reference to the node is given, while singly linked lists may require
O(n)
O(n) time if the previous node is not known.

3. Volatile keyword VS synchronized blocks
In Java, the volatile keyword ensures that updates to a variable are immediately visible to all threads and prevents instruction reordering,
guaranteeing memory visibility but not atomicity. In contrast, synchronized blocks provide both visibility and mutual exclusion,
ensuring only one thread can access a critical section at a time, which is necessary for compound operations. Volatile is lighter and suitable for simple flags,
while synchronized is needed for managing complex shared state with full consistency.

Synchronisation can slow down performance,
Instead we can use
lock less operation,
For example, AtomicInteger, CompareAndSwap

4. SerialVersionUUID and serialization!
Used for serialization
It is used to maintain the version.
Used to deserialize the same serialised object.

Relying on auto-generated UIDs can break deserialization if the class is modified, as the UID changes with each structural update.
Explicitly defining SerialVersionUID lets a class evolve (for example, adding fields) without breaking deserialization, as long as changes are compatible.
Backward compatibility is preserved if the SerialVersionUID remains unchanged with non-breaking changes;
older serialized objects can still be read by newer versions of the class.
Without an explicit SerialVersionUID, even minor structural changes may cause deserialization failures due to mismatched auto-generated UIDs,
making it harder to maintain backward compatibility over time.


5. Transaction & isolation levels.
READ COMMITTED allows transactions to see only committed data, preventing dirty reads and giving good performance,
but still allows non-repeatable and phantom reads, so perfect consistency is not guaranteed.

SERIALIZABLE provides the highest data consistency, making concurrent transactions appear as if executed sequentially,
but greatly reduces performance due to locking, blocking, and reduced concurrency.

Higher isolation levels improve data integrity but may slow down throughput, while lower levels boost performance at the risk of anomalies
like non-repeatable or phantom reads.

SERIALIZABLE: Example‚Äîwhen booking seats, two users cannot over-book due to strict isolation; each transaction is executed as if it were alone,
preventing conflicting data writes and guaranteeing consistent results.

READ COMMITTED: Example‚Äîbank account balance queries only show committed transactions,
but a second query in the same transaction might see a different balance due to concurrent updates (non-repeatable reads)

READ COMMITTED prevents dirty reads but allows non-repeatable reads, meaning repeated queries within the same transaction might return different results
as data can be changed and committed by others in between. This level provides good efficiency and throughput for highly concurrent systems,
making it a common default, but is not suitable if strong repeatable read consistency is required.


6. Constructor injection VS Setter injection VS Field injection!
Constructor Injection: Ensures all required dependencies are set, improves immutability, and supports testing well, but can get verbose with many parameters.
Setter Injection: Allows optional dependencies and later modification, but can lead to mutable, partially-initialized objects.
Field Injection: Simple and concise, but hides dependencies, makes testing harder, and relies on reflection, which is discouraged for production code.

Constructor injection enforces that all dependencies are provided up front, making it easy to supply mock or fake objects during unit testing,
and making missing dependencies fail fast at object creation.

Setter or field injection can result in incomplete or hidden dependencies, making it harder to track, mock, or verify injected values in tests.
This clarity and immutability from constructor injection leads to more predictable and reliable test code.

Constructor injection ensures that all dependencies are provided at the time the bean is created,
making the object fully initialized and immutable from the beginning of its lifecycle.
Setter and field injection fill dependencies after bean instantiation, leading to a period where the bean might be only partially constructed,
which can cause inconsistent state or errors if used too early.
This immediate initialization sequence with constructor injection results in safer, more predictable beans,
while setter/field injection may delay full readiness

7. The N+1 select problem in Hibernate occurs when fetching a list of parent entities triggers 1 query for the parents and then N separate queries for their children,
causing major performance issues. It arises due to default lazy loading of associations.
Solutions include using fetch joins (JOIN FETCH), batch fetching with @BatchSize, subselect fetching,
or entity graphs to load related data in fewer queries and avoid excessive database calls.

Batching‚Äîin Hibernate via @BatchSize‚Äîgroups child queries together, so instead of firing N queries, it fetches related data in fewer, larger batches,
reducing database round-trips and improving performance.
Alternatives include using JOIN FETCH for eager loading, entity graphs, or subselect strategies to load associations more efficiently.

Hibernate manages batching by grouping multiple entity fetch operations into single queries using the @BatchSize annotation on collections or entities.
You can also configure global batch size with the hibernate.default_batch_fetch_size property in your configuration file.
Batch fetching reduces the number of round-trips to the database by retrieving records in chunks with SQL IN clauses,
and tuning the batch size is essential for optimal performance.

Hibernate manages transactions using its Transaction interface, letting developers begin, commit,
or roll back transactions to ensure atomic operations and data integrity.
Programmatic transaction management involves manual control in the code (using explicit calls to begin, commit, rollback),
which increases flexibility but adds boilerplate and risk of human error.
Declarative transaction management uses annotations (e.g., @Transactional) or configuration to handle transactions automatically,
keeping business logic cleaner, reducing errors, and making transactional behavior easier to manage at scale.

Isolation levels like READ COMMITTED or SERIALIZABLE, when set via annotations (@Transactional(isolation = Isolation.SERIALIZABLE)),
control data visibility and consistency between concurrent transactions, impacting risks like dirty, non-repeatable, or phantom reads.
For custom rollback strategies, use @Transactional(rollbackFor = CustomException.class) to specify which exceptions trigger rollbacks,
or manually control transactions in code to decide when to commit or rollback based on business logic Isolation levels set via
annotations‚Äîsuch as @Transactional(isolation = Isolation.SERIALIZABLE)‚Äîcontrol how much concurrency and consistency a transaction has by determining which data changes are visible during execution.
To implement a custom rollback strategy, you can use the rollbackFor and noRollbackFor attributes in the @Transactional annotation (e.g., @Transactional(rollbackFor = CustomException.class)),
or manage the transaction programmatically to explicitly trigger rollback based on complex conditions or business logic.

To implement a custom rollback strategy, use the @Transactional(rollbackFor = CustomException.class) annotation to specify exactly which exceptions cause a rollback.
This ensures that only certain errors revert the transaction, improving control but requiring careful handling to avoid unintentionally committing inconsistent or partial data,
which could impact overall transaction consistency if not managed¬†properly.

